# Standard Library Imports
import hashlib
import uuid
import cryptography
import os
import logging
import asyncio
import smtplib
import ssl
from time import time
from datetime import datetime, timedelta

# Third-Party Imports
import jwt
import aiofiles
import aiohttp
import aiosqlite
import aiohttp_cors
from aiohttp import web
from aiohttp_session import setup, get_session, SimpleCookieStorage
from marshmallow import Schema, fields, ValidationError
import jwt.exceptions
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

#global variable to store outgoing reset requests
reset_requests = []

# Environment-based secret key for security (avoid hardcoding secrets)
SECRET_KEY = os.getenv('JWT_SECRET_KEY', 'secret_key_123')
PASSWORD_MIN_LENGTH = 8
PASSWORD_MAX_LENGTH = 20 #used for a vulnerability, roots password is too long to input, needs to be reset

# Set up logging (structured JSON format)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# CORS setup options
CORS_OPTIONS = {
    "*": aiohttp_cors.ResourceOptions(
        allow_credentials=True,
        expose_headers="*",
        allow_headers="*",
        allow_methods="*"
    )
}

class RegisterSchema(Schema):
    username = fields.Str(required=True)
    email = fields.Email(required=True)
    password = fields.Str(required=True)


class LoginSchema(Schema):
    username = fields.Str(required=True)
    password = fields.Str(required=True)


class ResetSchema(Schema):
    email = fields.Email(required=True)


@web.middleware
async def error_middleware(request, handler):
    try:
        response = await handler(request)

        if response.status == 404:
            logger.warning(f"404 Not Found: {request.method} {request.url}")
            return web.json_response({"message": "404: Page not found"}, status=404)
        if response.status >= 400:
            logger.warning(f"Client Error {response.status}: {request.method} {request.url}")
        return response

    except web.HTTPException as ex:
        if ex.status == 404:
            logger.warning(f"404 Not Found: {request.method} {request.url}")
            return web.json_response({"message": "404: Page not found"}, status=404)
        elif ex.status == 400:
            logger.warning(f"400 Bad Request: {request.method} {request.url}")
            return web.json_response({"message": "400: Bad request"}, status=400)
        elif ex.status == 403:
            logger.warning(f"403 Forbidden: {request.method} {request.url}")
            return web.json_response({"message": "403: Forbidden"}, status=403)
        elif ex.status == 401:
            logger.warning(f"401 Unauthorized: {request.method} {request.url}")
            return web.json_response({"message": "401: Unauthorized"}, status=401)
        elif ex.status == 500:
            logger.error(f"500 Internal Server Error: {request.method} {request.url}")
            return web.json_response({"message": "500: Internal server error"}, status=500)
        else:
            logger.error(f"HTTP {ex.status}: {request.method} {request.url} - {ex.reason}")
            return web.json_response({"message": ex.reason or "An HTTP error occurred"}, status=ex.status)

    except Exception as e:
        logger.error(f"500 Internal Server Error: {request.method} {request.url} - {str(e)}")
        return web.json_response({"message": "500: Internal server error"}, status=500)


def create_jwt(username, roles=None):
    payload = {
        'username': username,
        'roles': roles or ['user'],
        'exp': datetime.utcnow() + timedelta(hours=1),
        'iat': datetime.utcnow()
    }
    return jwt.encode(payload, SECRET_KEY, algorithm='HS256')


def decode_jwt(token):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
        return payload
    except jwt.ExpiredSignatureError:
        logger.warning("JWT has expired")
        return None
    except jwt.InvalidTokenError:
        logger.error("Invalid JWT token")
        return None

# JWT-based RBAC middleware
@web.middleware
async def rbac_middleware(request, handler): #TODO fix this!!
    # List of public routes that don't require a token
    public_routes = ['/', '/favicon.ico', '/register', '/login', 'logout', '/userflag', '/adminflag', '/reset', '/reset-request', '/shell']

    if request.path in public_routes:
        return await handler(request)

    token = request.headers.get('authorization')
    if not token:
        logger.warning("Missing token")
        return web.json_response({"message": "Missing token"}, status=401)

    decoded = decode_jwt(token)
    if not decoded:
        logger.warning("Invalid or expired token")
        return web.json_response({"message": "Invalid or expired token"}, status=401)

    request['user'] = decoded
    return await handler(request)


# Input validation helper
async def validate_schema(schema, request):
    try:
        data = await request.json()
        return schema.load(data)
    except ValidationError as err:
        return web.json_response({"errors": err.messages}, status=400)


# Register handler
async def handle_register(request):
    data = await validate_schema(RegisterSchema(), request)
    if isinstance(data, web.Response):
        return data
    
    if (len(data["password"]) > PASSWORD_MAX_LENGTH):
        return web.json_response({"message": "Password too long (maximum is " + str(PASSWORD_MAX_LENGTH) + ")"}, status=400)
    elif (len(data["password"]) < PASSWORD_MIN_LENGTH):
        return web.json_response({"message": "Password too short (minimum is " + str(PASSWORD_MIN_LENGTH) + ")"}, status=400)

    hashed_password = hashlib.sha1(data["password"].encode()).hexdigest() #insecurely hashed with sha1

    async with aiosqlite.connect('webserver.db') as db:
        vuln_query = "SELECT COUNT(*) FROM users WHERE username = \"" + data["username"] + "\"" 
        async with db.execute(vuln_query) as cursor:
            row = await cursor.fetchone()

        print(vuln_query)
        print(row[0])
        print(row[0] != 0)

        if (row[0] != 0): #vulnerable to blind sqli
            return web.json_response({"message": "Username already taken"}, status=400)
        try:
            await db.execute(
            "INSERT INTO users (id, username, password, password_len, email, role) VALUES (?, ?, ?, ?, ?, ?)",
            (str(uuid.uuid4().int)[:8], data['username'], hashed_password, len(data["password"]), data['email'], 'unverified')
            )
        except: #failsafe for duplicate name that bypasses the vulnerable check, pretend it gets added
            return web.json_response({"message": "User registered \"successfully\". Please wait to be verified."}, status=201)
        await db.commit()

    return web.json_response({"message": "User registered successfully. Please wait to be verified."}, status=201)


# Login handler
async def handle_login(request):
    data = await validate_schema(LoginSchema(), request)
    if isinstance(data, web.Response):
        return data
    
    async with aiosqlite.connect('webserver.db') as db:
        async with db.execute("SELECT password, role FROM users WHERE username = ?", (data['username'],)) as cursor:
            row = await cursor.fetchone()

    if row[1] == "unverified":
        return web.json_response({"message": "Account is unverified. Please wait to be verified"}, status=401)
    elif ((hashlib.sha1(data["password"].encode()).hexdigest()) == row[0]):
        token = create_jwt(data['username'], row[1])
        return web.json_response({"message": "Login successful", "token": token}, status=200)
    else:
        return web.json_response({"message": "Invalid credentials"}, status=401)

# Function to generate a cryptographically INsecure reset token
# Uses IBM RANDU, with offset start
async def generate_reset_token():
    async with aiosqlite.connect('webserver.db') as db:
        async with db.execute("SELECT count FROM reset_count_pls_ignore") as cursor:
            count = await cursor.fetchone()

        token = 1 #initial seed is 1
        for i in range(0, count[0]): #iterate count times to get nth value in sequence
            token = ((token * 65539) % 2**31)

        await db.execute("UPDATE reset_count_pls_ignore SET count = ?", (count[0]+1,))
        await db.commit()

    return token


# Password reset request handler
async def handle_password_reset_request(request):
    data = await request.json()
    jwt_token = data.get('jwtToken', '').strip()
    email = data.get('email', '').strip()

    # Validate input
    if not email:
        return web.json_response({"message": "Missing email"}, status=400)
    
    if (not is_user(jwt_token)):
        return web.json_response({"message": "Not logged in"}, status=400)

    try:
        async with aiosqlite.connect('webserver.db') as db:
            # Use parameterized query to prevent SQL injection
            async with db.execute("SELECT id FROM users WHERE email = ?", (email,)) as cursor:
                user = await cursor.fetchone()

        if not user:
            logging.warning("Password reset attempt for non-existent user")
            return web.json_response({"message": "User not found"}, status=200)            

        # Generate an insecure reset token
        reset_token = await generate_reset_token()

        #Store id/token pair in variable
        reset_requests.append((user[0], reset_token))

        # Send an email to the provided email address
        await send_reset_email(user[0], reset_token, email)

        logging.info(f"Password reset token generated {str(reset_token)}")
        logging.info(f"Requests status {str(reset_requests)}")
        return web.json_response({"message": f"Reset email sent to {email}"}, status=200)

    except aiosqlite.Error as e:
        logging.error(f"Database error during password reset request: {str(e)}")
        return web.json_response({"message": "Internal server error"}, status=500)

    except Exception as e:
        logging.error(f"Unexpected error during password reset request: {str(e)}")
        return web.json_response({"message": "Internal server error"}, status=500)

# Sends the reset email to the email address
async def send_reset_email(id, token, email):
    #smtp ssl info
    port = 465 #ssl port
    sender_email = "donthackthemessengerplease@gmail.com"
    password = "kiix stjd brjw yehf" #this is the genuine password for the gmail api dont abuse this please
    context = ssl.create_default_context()

    message = MIMEMultipart("alternative")
    message["Subject"] = "Password Reset"
    message["From"] = "Vulnerable Web Server"
    message["To"] = email

    text = """\
    Reset Token: %s
    User ID: %s
    """ % (str(token), str(id))

    plaintext_message = MIMEText(text, "plain")

    message.attach(plaintext_message)

    #establish ssl conenction with gmail
    with smtplib.SMTP_SSL("smtp.gmail.com", port, context=context) as server:
        server.login(sender_email, password)
        server.sendmail(sender_email, email, message.as_string())
    
    return

# Password reset handler
async def handle_password_reset(request):
    data = await request.json()
    jwt_token = data.get('jwtToken', '').strip()
    reset_token = data.get('token', '').strip()
    user_id = data.get('id', '').strip()
    new_password = data.get('password', '').strip()

    # Validate inputs
    if not reset_token or not new_password:
        return web.json_response({"message": "Missing token or new password"}, status=400)
    
    if (not is_user(jwt_token)):
        return web.json_response({"message": "Not logged in"}, status=400)

    # Enforce password policy
    if (len(data["password"]) > PASSWORD_MAX_LENGTH):
        return web.json_response({"message": "Password too long (maximum is " + str(PASSWORD_MAX_LENGTH) + ")"}, status=400)
    elif (len(data["password"]) < PASSWORD_MIN_LENGTH):
        return web.json_response({"message": "Password too short (minimum is " + str(PASSWORD_MIN_LENGTH) + ")"}, status=400)

    #check if token and id are valid
    if ((int(user_id), int(reset_token)) not in reset_requests):
        return web.json_response({"message": "Invalid token or user ID"}, status=400)

    # Hash the new password
    hashed_password = hashlib.sha1(new_password.encode()).hexdigest()

    try:
        # Update the user's password
        async with aiosqlite.connect('webserver.db') as db:
            await db.execute(
                "UPDATE users SET password = ? WHERE id = ?",
                (hashed_password, user_id)
            )
            await db.commit()

        reset_requests.remove((int(user_id), int(reset_token)))
        logging.info(f"Password reset successful for token: {reset_token}")
        logging.info(f"Requests status {str(reset_requests)}")
        return web.json_response({"message": "Password reset successful"}, status=200)
        

    except aiosqlite.Error as e:
        logging.error(f"Database error during password reset: {str(e)}")
        return web.json_response({"message": "Internal server error"}, status=500)

    except Exception as e:
        logging.error(f"Unexpected error during password reset: {str(e)}")
        return web.json_response({"message": "Internal server error"}, status=500)


# --- DB Setup ---
async def init_db():
    async with aiosqlite.connect('webserver.db') as db:
        # Create tables
        await db.execute('''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY,
                username TEXT NOT NULL UNIQUE,
                password TEXT NOT NULL,
                password_len INTEGER,
                role TEXT NOT NULL DEFAULT 'unverified',
                email TEXT NOT NULL
            )
        ''')
        await db.execute('''
            CREATE TABLE IF NOT EXISTS reset_count_pls_ignore (
                count INTEGER
            )
        ''')
        await db.commit()

# --- DB User Creation ---
async def init_users():
    async with aiosqlite.connect('webserver.db') as db:
        await db.execute(
            "INSERT INTO users (password, password_len, id, username, email, role) VALUES (?, ?, ?, ?, ?, ?)",
            ((hashlib.sha1("mypasswordistoolongtoinputhahahahaha".encode()).hexdigest()), len("mypasswordistoolongtoinputhahahahaha"),
            str(uuid.uuid4().int)[:8], "root", "resetme@127.0.0.1.com", "admin")
        )
        await db.execute(
            "INSERT INTO users (password, password_len, id, username, email, role) VALUES (?, ?, ?, ?, ?, ?)",
            ((hashlib.sha1("ILOVESHA1HASHES".encode()).hexdigest()), len("ILOVESHA1HASHES"),
            str(uuid.uuid4().int)[:8], "SHA1Guys", "weresha1guysofcoursewebruteforce@127.0.0.1.com", "user")
        )
        await db.execute(
            "INSERT INTO users (password, password_len, id, username, email, role) VALUES (?, ?, ?, ?, ?, ?)",
            ((hashlib.sha1("notnotmypassword".encode()).hexdigest()), len("notnotmypassword"),
            str(uuid.uuid4().int)[:8], "not_vulnerable", "wewontwewontrockyou@127.0.0.1.com", "user")
        )
        await db.execute(
            "INSERT INTO users (password, password_len, id, username, email, role) VALUES (?, ?, ?, ?, ?, ?)",
            ((hashlib.sha1("robloxer".encode()).hexdigest()), len("robloxer"),         
            str(uuid.uuid4().int)[:8], "strongestwarrior2008", "?l?l?l?l@127.0.0.1.com", "user")
        )

        await db.execute("INSERT INTO reset_count_pls_ignore (count) VALUES (32)")

        await db.commit()

# Logout
async def handle_logout(request):
    session = await get_session(request)
    session.invalidate()
    return web.json_response({"message": "Logged out successfully"}, status=200)

# Open shell
async def handle_shell():
    #TODO add shell opening sys command
    pass

async def handle_userflag(request):
    data = await request.json()
    token = data.get('jwtToken', '').strip()
    if (is_user(token)):
        return web.json_response({"message": "You found the user flag!\n FLAG{CurtainCenturyYouth}"}, status=200)
    else:
        return web.json_response({"message": "You need to login as a user first!"}, status=200)
    
async def handle_adminflag(request):
    data = await request.json()
    token = data.get('jstToken', '').strip()
    if (is_admin(token)):
        return web.json_response({"message": "You found the user flag!\n FLAG{CurtainCenturyYouth}"}, status=200)
    else:
        return web.json_response({"message": "You need to login as an admin first!"}, status=200)

async def is_admin(token):
    decoded = decode_jwt(token)
    if not decoded:
        return False

    async with aiosqlite.connect('webserver.db') as db:
        async with db.execute("SELECT role FROM users WHERE username = ?", (decoded['username'],)) as cursor:
            user = await cursor.fetchone()

    return user[0] == 'admin'

async def is_user(token):
    decoded = decode_jwt(token)
    if not decoded:
        return False
    else:
        return True

# --- App Initialization ---
async def init_app():
    app = web.Application(middlewares=[error_middleware, rbac_middleware])

    # Setup CORS
    cors = aiohttp_cors.setup(app, defaults=CORS_OPTIONS)
    
    # Setup session storage
    setup(app, SimpleCookieStorage())

    # Initialize the database
    await init_db()

    #init the users (commented out, only use if webserver.db is deleted, not safe with duplicates)
    #await init_users()

    # Add routes
    app.router.add_post('/register', handle_register)
    app.router.add_post('/login', handle_login)
    app.router.add_post('/reset-request', handle_password_reset_request)
    app.router.add_post('/reset', handle_password_reset)
    app.router.add_post('/shell', handle_shell)
    app.router.add_post('/userflag', handle_userflag)
    app.router.add_post('/adminflag', handle_adminflag)

    # Apply CORS to all routes
    for route in app.router.routes():
        cors.add(route)

    return app


# Start the web server
if __name__ == '__main__':
    app = init_app()
    web.run_app(app, port=8080)
