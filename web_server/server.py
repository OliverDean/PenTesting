# Standard Library Imports
import hashlib
import uuid
import cryptography
import os
import logging
import asyncio
import smtplib
import ssl
from time import time
from datetime import datetime, timedelta

# Third-Party Imports
import jwt
import aiofiles
import aiohttp
import aiosqlite
import aiohttp_cors
from aiohttp import web
from aiohttp_session import setup, get_session, SimpleCookieStorage
from marshmallow import Schema, fields, ValidationError
import jwt.exceptions
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

# Global variable to store outgoing reset requests
reset_requests = []

# Environment-based secret key for security (avoid hardcoding secrets)
SECRET_KEY = os.getenv('JWT_SECRET_KEY', 'secret_key_123')
PASSWORD_MIN_LENGTH = 8
PASSWORD_MAX_LENGTH = 20  # Used for a vulnerability, root's password is too long to input, needs to be reset

# Set up logging (structured JSON format)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# CORS setup options
CORS_OPTIONS = {
    "*": aiohttp_cors.ResourceOptions(
        allow_credentials=True,
        expose_headers="*",
        allow_headers="*",
        allow_methods="*"
    )
}

class RegisterSchema(Schema):
    username = fields.Str(required=True)
    email = fields.Email(required=True)
    password = fields.Str(required=True)

class CheckSchema(Schema):
    username = fields.Str(required=True)
    
class LoginSchema(Schema):
    username = fields.Str(required=True)
    password = fields.Str(required=True)


class ResetSchema(Schema):
    email = fields.Email(required=True)


@web.middleware
async def error_middleware(request, handler):
    try:
        response = await handler(request)

        if response.status == 404:
            logger.warning(f"404 Not Found: {request.method} {request.url}")
            return web.json_response({"message": "404: Page not found"}, status=404)
        if response.status >= 400:
            logger.warning(f"Client Error {response.status}: {request.method} {request.url}")
        return response

    except web.HTTPException as ex:
        if ex.status == 404:
            logger.warning(f"404 Not Found: {request.method} {request.url}")
            return web.json_response({"message": "404: Page not found"}, status=404)
        elif ex.status == 400:
            logger.warning(f"400 Bad Request: {request.method} {request.url}")
            return web.json_response({"message": "400: Bad request"}, status=400)
        elif ex.status == 403:
            logger.warning(f"403 Forbidden: {request.method} {request.url}")
            return web.json_response({"message": "403: Forbidden"}, status=403)
        elif ex.status == 401:
            logger.warning(f"401 Unauthorized: {request.method} {request.url}")
            return web.json_response({"message": "401: Unauthorized"}, status=401)
        elif ex.status == 500:
            logger.error(f"500 Internal Server Error: {request.method} {request.url}")
            return web.json_response({"message": "500: Internal server error"}, status=500)
        else:
            logger.error(f"HTTP {ex.status}: {request.method} {request.url} - {ex.reason}")
            return web.json_response({"message": ex.reason or "An HTTP error occurred"}, status=ex.status)

    except Exception as e:
        logger.error(f"500 Internal Server Error: {request.method} {request.url} - {str(e)}")
        return web.json_response({"message": "500: Internal server error"}, status=500)


def create_jwt(username, role=None):
    payload = {
        'username': username,
        'roles': [role] if role else ['user'],
        'exp': datetime.utcnow() + timedelta(hours=1),
        'iat': datetime.utcnow()
    }
    return jwt.encode(payload, SECRET_KEY, algorithm='HS256')


def decode_jwt(token):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
        return payload
    except jwt.ExpiredSignatureError:
        logger.warning("JWT has expired")
        return None
    except jwt.InvalidTokenError:
        logger.error("Invalid JWT token")
        return None

# JWT-based RBAC middleware with role support
@web.middleware
async def rbac_middleware(request, handler):
    # Define routes and their required roles
    role_required_routes = {
        '/shell': 'admin',
        '/adminflag': 'admin',
        '/userflag': 'user',  # Assuming user flag requires at least 'user' role
        # Add more routes and roles as needed
    }

    path = request.path

    # Public routes that don't require authentication
    public_routes = [
        '/', '/favicon.ico', '/register', '/login', 
        '/logout', '/reset', '/reset-request', './static/', '/static'
    ]

    # Allow public routes
    path = request.path
    if path in public_routes:
        return await handler(request)

    # Check if the current route requires a specific role
    required_role = role_required_routes.get(path)

    if not required_role:
        # Define public routes that don't require any authentication
        public_routes = ['/', '/favicon.ico', '/register', '/login', '/logout', '/reset', '/reset-request', '/static/styles.css', '/static/scripts.js']
        if path in public_routes:
            return await handler(request)
        else:
            # If route is not defined in role_required_routes or public_routes, deny access
            logger.warning(f"Access denied to undefined route: {path}")
            return web.json_response({"message": "Access denied"}, status=403)

    # For routes that require specific roles
    token = request.headers.get('authorization')
    if not token:
        logger.warning("Missing token")
        return web.json_response({"message": "Missing token"}, status=401)

    decoded = decode_jwt(token)
    if not decoded:
        logger.warning("Invalid or expired token")
        return web.json_response({"message": "Invalid or expired token"}, status=401)

    user_roles = decoded.get('roles', [])
    if required_role not in user_roles:
        logger.warning(f"User does not have the required role: {required_role}")
        return web.json_response({"message": "Forbidden: Insufficient privileges"}, status=403)

    request['user'] = decoded
    return await handler(request)

# Input validation helper
async def validate_schema(schema, request):
    try:
        data = await request.json()
        return schema.load(data)
    except ValidationError as err:
        return web.json_response({"errors": err.messages}, status=400)

async def handle_check(request):
    print(request)
    data = await validate_schema(CheckSchema(), request)

    async with aiosqlite.connect('webserver.db') as db:
        vuln_query = "SELECT id FROM users WHERE username = \"" + data["username"] + "\"" 
        print(vuln_query)
        async with db.execute(vuln_query) as cursor:
            try:
                row = await cursor.fetchone()
                if (row != None):
                    return web.json_response({"message": "Username already taken"}, status=201)
                else:
                    return web.json_response({"message": "Username is available"}, status=201)
            except:
                    return web.json_response({"message": "Error checking database"}, status=500)


# Register handler
async def handle_register(request):
    data = await validate_schema(RegisterSchema(), request)
    if isinstance(data, web.Response):
        return data

    if (len(data["password"]) > PASSWORD_MAX_LENGTH):
        return web.json_response({"message": "Password too long (maximum is " + str(PASSWORD_MAX_LENGTH) + ")"}, status=400)
    elif (len(data["password"]) < PASSWORD_MIN_LENGTH):
        return web.json_response({"message": "Password too short (minimum is " + str(PASSWORD_MIN_LENGTH) + ")"}, status=400)

    hashed_password = hashlib.sha1(data["password"].encode()).hexdigest()  # Insecurely hashed with sha1

    async with aiosqlite.connect('webserver.db') as db:
        vuln_query = "SELECT id FROM users WHERE username = \"" + data["username"] + "\"" 
        print(vuln_query)
        async with db.execute(vuln_query) as cursor:
            try:
                row = await cursor.fetchone()
                if (row != None):
                    return web.json_response({"message": "Username already taken"}, status=500)
            except:
                pass

        try:
            await db.execute(
                "INSERT INTO users (id, username, password, password_len, email, role) VALUES (?, ?, ?, ?, ?, ?)",
                (str(uuid.uuid4().int)[:8], data['username'], hashed_password, len(data["password"]), data['email'], 'unverified')
            )
        except:  # Failsafe for duplicate name that bypasses the vulnerable check, pretend it gets added
            return web.json_response({"message": "User registered \"successfully\". Please wait to be verified."}, status=201)
        await db.commit()

    return web.json_response({"message": "User registered successfully. Please wait to be verified."}, status=201)


# Login handler
async def handle_login(request):
    data = await validate_schema(LoginSchema(), request)
    if isinstance(data, web.Response):
        return data

    async with aiosqlite.connect('webserver.db') as db:
        async with db.execute("SELECT password, role FROM users WHERE username = ?", (data['username'],)) as cursor:
            row = await cursor.fetchone()

    if row is None:
        return web.json_response({"message": "Invalid credentials"}, status=401)

    if row[1] == "unverified":
        return web.json_response({"message": "Account is unverified. Please wait to be verified"}, status=401)
    elif ((hashlib.sha1(data["password"].encode()).hexdigest()) == row[0]):
        token = create_jwt(data['username'], row[1])  # role is passed as a single value
        return web.json_response({"message": "Login successful", "token": token}, status=200)
    else:
        return web.json_response({"message": "Invalid credentials"}, status=401)


# Function to generate a cryptographically INsecure reset token
# Uses IBM RANDU, with offset start
async def generate_reset_token():
    async with aiosqlite.connect('webserver.db') as db:
        async with db.execute("SELECT count FROM reset_count_pls_ignore") as cursor:
            count = await cursor.fetchone()

        token = 1  # Initial seed is 1
        for i in range(0, count[0]):  # Iterate count times to get nth value in sequence
            token = ((token * 65539) % 2**31)

        await db.execute("UPDATE reset_count_pls_ignore SET count = ?", (count[0]+1,))
        await db.commit()

    return token


# Password reset request handler
async def handle_password_reset_request(request):
    data = await request.json()
    jwt_token = data.get('jwtToken', '').strip()
    email = data.get('email', '').strip()

    # Validate input
    if not email:
        return web.json_response({"message": "Missing email"}, status=400)
    
    if (not is_user(jwt_token)):
        return web.json_response({"message": "Not logged in"}, status=400)

    try:
        async with aiosqlite.connect('webserver.db') as db:
            # Use parameterized query to prevent SQL injection
            async with db.execute("SELECT id FROM users WHERE email = ?", (email,)) as cursor:
                user = await cursor.fetchone()

        if not user:
            logging.warning("Password reset attempt for non-existent user")
            return web.json_response({"message": "User not found"}, status=200)            

        # Generate an insecure reset token
        reset_token = await generate_reset_token()

        # Store id/token pair in variable
        reset_requests.append((user[0], reset_token))

        # Send an email to the provided email address
        await send_reset_email(user[0], reset_token, email)

        logging.info(f"Password reset token generated {str(reset_token)}")
        logging.info(f"Requests status {str(reset_requests)}")
        return web.json_response({"message": f"Reset email sent to {email}"}, status=200)

    except aiosqlite.Error as e:
        logging.error(f"Database error during password reset request: {str(e)}")
        return web.json_response({"message": "Internal server error"}, status=500)

    except Exception as e:
        logging.error(f"Unexpected error during password reset request: {str(e)}")
        return web.json_response({"message": "Internal server error"}, status=500)


# Sends the reset email to the email address
async def send_reset_email(id, token, email):
    # SMTP SSL info
    port = 465  # SSL port
    sender_email = "donthackthemessengerplease@gmail.com"
    password = "kiix stjd brjw yehf"  # This is the genuine password for the gmail API, don't abuse this please
    context = ssl.create_default_context()

    message = MIMEMultipart("alternative")
    message["Subject"] = "Password Reset"
    message["From"] = "Vulnerable Web Server"
    message["To"] = email

    text = """\
    Reset Token: %s
    User ID: %s
    """ % (str(token), str(id))

    plaintext_message = MIMEText(text, "plain")

    message.attach(plaintext_message)

    # Establish SSL connection with Gmail
    with smtplib.SMTP_SSL("smtp.gmail.com", port, context=context) as server:
        server.login(sender_email, password)
        server.sendmail(sender_email, email, message.as_string())
    
    return


# Password reset handler
async def handle_password_reset(request):
    data = await request.json()
    jwt_token = data.get('jwtToken', '').strip()
    reset_token = data.get('token', '').strip()
    user_id = data.get('id', '').strip()
    new_password = data.get('password', '').strip()

    # Validate inputs
    if not reset_token or not new_password:
        return web.json_response({"message": "Missing token or new password"}, status=400)
    
    if (not is_user(jwt_token)):
        return web.json_response({"message": "Not logged in"}, status=400)

    # Enforce password policy
    if (len(data["password"]) > PASSWORD_MAX_LENGTH):
        return web.json_response({"message": "Password too long (maximum is " + str(PASSWORD_MAX_LENGTH) + ")"}, status=400)
    elif (len(data["password"]) < PASSWORD_MIN_LENGTH):
        return web.json_response({"message": "Password too short (minimum is " + str(PASSWORD_MIN_LENGTH) + ")"}, status=400)

    # Check if token and id are valid
    if ((int(user_id), int(reset_token)) not in reset_requests):
        return web.json_response({"message": "Invalid token or user ID"}, status=400)

    # Hash the new password
    hashed_password = hashlib.sha1(new_password.encode()).hexdigest()

    try:
        # Update the user's password
        async with aiosqlite.connect('webserver.db') as db:
            await db.execute(
                "UPDATE users SET password = ? WHERE id = ?",
                (hashed_password, user_id)
            )
            await db.commit()

        reset_requests.remove((int(user_id), int(reset_token)))
        logging.info(f"Password reset successful for token: {reset_token}")
        logging.info(f"Requests status {str(reset_requests)}")
        return web.json_response({"message": "Password reset successful"}, status=200)
        

    except aiosqlite.Error as e:
        logging.error(f"Database error during password reset: {str(e)}")
        return web.json_response({"message": "Internal server error"}, status=500)

    except Exception as e:
        logging.error(f"Unexpected error during password reset: {str(e)}")
        return web.json_response({"message": "Internal server error"}, status=500)


# --- DB Setup ---
async def init_db():
    async with aiosqlite.connect('webserver.db') as db:
        # Create tables
        await db.execute('''
            CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, username TEXT NOT NULL UNIQUE, password TEXT NOT NULL, password_len INTEGER, role TEXT NOT NULL DEFAULT 'unverified', email TEXT NOT NULL)
        ''') #needs to be one line or sqli is too hard
        await db.execute('''
            CREATE TABLE IF NOT EXISTS reset_count_pls_ignore (count INTEGER)
        ''')
        # Initialize reset_count_pls_ignore if empty
        async with db.execute("SELECT COUNT(*) FROM reset_count_pls_ignore") as cursor:
            count = await cursor.fetchone()
            if count[0] == 0:
                await db.execute("INSERT INTO reset_count_pls_ignore (count) VALUES (32)")
        await db.commit()


# --- DB User Creation ---
async def init_users():
    async with aiosqlite.connect('webserver.db') as db:
        await db.execute(
            "INSERT INTO users (password, password_len, id, username, email, role) VALUES (?, ?, ?, ?, ?, ?)",
            ((hashlib.sha1("mypasswordistoolongtoinputhahahahaha".encode()).hexdigest()), len("mypasswordistoolongtoinputhahahahaha"),
            str(uuid.uuid4().int)[:8], "root", "resetme@127.0.0.1.com", "admin")
        )
        await db.execute(
            "INSERT INTO users (password, password_len, id, username, email, role) VALUES (?, ?, ?, ?, ?, ?)",
            ((hashlib.sha1("ILOVESHA1HASHES".encode()).hexdigest()), len("ILOVESHA1HASHES"),
            str(uuid.uuid4().int)[:8], "SHA1Guys", "weresha1guysofcoursewebruteforce@127.0.0.1.com", "user")
        )
        await db.execute(
            "INSERT INTO users (password, password_len, id, username, email, role) VALUES (?, ?, ?, ?, ?, ?)",
            ((hashlib.sha1("notnotmypassword".encode()).hexdigest()), len("notnotmypassword"),
            str(uuid.uuid4().int)[:8], "not_vulnerable", "wewontwewontrockyou@127.0.0.1.com", "user")
        )
        await db.execute(
            "INSERT INTO users (password, password_len, id, username, email, role) VALUES (?, ?, ?, ?, ?, ?)",
            ((hashlib.sha1("robloxer".encode()).hexdigest()), len("robloxer"),         
            str(uuid.uuid4().int)[:8], "strongestwarrior2008", "?l?l?l?l@127.0.0.1.com", "user")
        )

        await db.commit()

# Logout
async def handle_logout(request):
    session = await get_session(request)
    session.invalidate()
    return web.json_response({"message": "Logged out successfully"}, status=200)

# Open shell
async def handle_shell(request):
    # Vulnerable Shell Handler: Executes system commands passed via query parameters or POST data
    if request.method == 'GET':
        params = request.rel_url.query
        cmd = params.get('cmd', '').strip()
    elif request.method == 'POST':
        data = await request.json()
        cmd = data.get('cmd', '').strip()
    else:
        return web.json_response({"message": "Method not allowed"}, status=405)

    if not cmd:
        return web.json_response({"message": "No command provided"}, status=400)

    try:
        # Execute the command and capture the output
        process = await asyncio.create_subprocess_shell(
            cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE)
        stdout, stderr = await process.communicate()

        response = {
            "command": cmd,
            "stdout": stdout.decode(),
            "stderr": stderr.decode(),
            "returncode": process.returncode
        }
        return web.json_response(response, status=200)
    except Exception as e:
        logger.error(f"Error executing command: {str(e)}")
        return web.json_response({"message": "Error executing command"}, status=500)


async def handle_userflag(request):
    data = await request.json()
    token = data.get('jwtToken', '').strip()
    if (is_user(token)):
        return web.json_response({"message": "You found the user flag!\nFLAG{CurtainCenturyYouth}"}, status=200)
    else:
        return web.json_response({"message": "You need to login as a user first!"}, status=200)
    
async def handle_adminflag(request):
    data = await request.json()
    token = data.get('jwtToken', '').strip()
    if (is_admin(token)):
        return web.json_response({"message": "You found the admin flag!\nFLAG{MasterKeyAccessGranted}"}, status=200)
    else:
        return web.json_response({"message": "You need to login as an admin first!"}, status=403)

async def is_admin(token):
    decoded = decode_jwt(token)
    if not decoded:
        return False

    async with aiosqlite.connect('webserver.db') as db:
        async with db.execute("SELECT role FROM users WHERE username = ?", (decoded['username'],)) as cursor:
            user = await cursor.fetchone()

    return user and user[0] == 'admin'

async def is_user(token):
    decoded = decode_jwt(token)
    if not decoded:
        return False
    else:
        return True

# --- App Initialization ---
async def init_app():
    app = web.Application(middlewares=[error_middleware, rbac_middleware])

    # Setup CORS
    cors = aiohttp_cors.setup(app, defaults=CORS_OPTIONS)
    
    # Setup session storage
    setup(app, SimpleCookieStorage())

    # Initialize the database
    await init_db()

    # Initialize the users (commented out, only use if webserver.db is deleted, not safe with duplicates)
    # await init_users()

    # Add routes
    # POST Routes
    app.router.add_post('/register', handle_register)
    app.router.add_post('/check', handle_check)
    app.router.add_post('/login', handle_login)
    app.router.add_post('/reset-request', handle_password_reset_request)
    app.router.add_post('/reset', handle_password_reset)
    app.router.add_post('/shell', handle_shell)
    app.router.add_post('/userflag', handle_userflag)
    app.router.add_post('/adminflag', handle_adminflag)
    app.router.add_post('/logout', handle_logout)

    # GET Routes
    app.router.add_get('/', handle_homepage)
    app.router.add_get('/favicon.ico', handle_favicon)
    app.router.add_get('/shell', handle_shell_page)

    # Static File Routes
    static_path = os.path.abspath('./static')
    app.router.add_static('/static/', path=static_path, name='static', show_index=True)

    # Apply CORS to all routes
    for route in app.router.routes():
        cors.add(route)

    return app


# --- GET Route Handlers ---

# Home Page Handler
async def handle_homepage(request):
    async with aiofiles.open('./static/index.html', mode='r') as f:
        content = await f.read()
    return web.Response(text=content, content_type='text/html')

# Favicon Handler
async def handle_favicon(request):
    # Return a simple favicon or a placeholder
    return web.Response(status=204)

# Shell Page Handler
async def handle_shell_page(request):
    async with aiofiles.open('./static/shell.html', mode='r') as f:
        content = await f.read()
    return web.Response(text=content, content_type='text/html')

# script handler
async def handle_scripts(request):
    print("get request from html")


# Start the web server
if __name__ == '__main__':
    import os
    print(os.path.abspath('./static'))
    print(os.path.abspath('./server.py'))
    print(os.path.abspath('./static/styles.css'))
    print(os.path.abspath('./static/scripts.js'))
    web.run_app(init_app(), port=8080)

