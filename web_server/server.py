# Standard Library Imports
import hashlib
import uuid
import cryptography
import os
import asyncio
import logging
import asyncio
import random
import string
import secrets
import mimetypes
from collections import defaultdict
from time import time
from datetime import datetime, timedelta

# Third-Party Imports
import bcrypt
import jwt
import aiofiles
import aiohttp
import aiosqlite
import aiohttp_cors
from aiohttp import web
from aiohttp_session import setup, get_session, SimpleCookieStorage
from marshmallow import Schema, fields, ValidationError
import jwt.exceptions

# Environment-based secret key for security (avoid hardcoding secrets)
SECRET_KEY = os.getenv('JWT_SECRET_KEY', 'supersecret')
PASSWORD_MIN_LENGTH = 8
PASSWORD_MAX_LENGTH = 20 #used for a vulnerability, roots password is too long to input, needs to be reset

# Set up logging (structured JSON format)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# CORS setup options
CORS_OPTIONS = {
    "*": aiohttp_cors.ResourceOptions(
        allow_credentials=True,
        expose_headers="*",
        allow_headers="*",
    )
}

# File handling settings
ALLOWED_EXTENSIONS = {'.jpg', '.jpeg', '.png', '.pdf', '.txt', '.docx', '.xlsx'}
MAX_FILE_SIZE = 5 * 1024 * 1024  # 5 MB limit for file uploads

MAX_LIMIT = 100

class RegisterSchema(Schema):
    username = fields.Str(required=True)
    email = fields.Email(required=True)
    password = fields.Str(required=True, validate=lambda p: PASSWORD_MAX_LENGTH >= len(p) >= PASSWORD_MIN_LENGTH)


class LoginSchema(Schema):
    username = fields.Str(required=True)
    password = fields.Str(required=True, validate=lambda p: PASSWORD_MAX_LENGTH >= len(p) >= PASSWORD_MIN_LENGTH)


class ProfileUpdateSchema(Schema):
    email = fields.Email(required=True)
    password = fields.Str(required=True, validate=lambda p: PASSWORD_MAX_LENGTH >= len(p) >= PASSWORD_MIN_LENGTH)


@web.middleware
async def error_middleware(request, handler):
    try:
        response = await handler(request)

        if response.status == 404:
            logger.warning(f"404 Not Found: {request.method} {request.url}")
            return web.json_response({"message": "404: Page not found"}, status=404)
        if response.status >= 400:
            logger.warning(f"Client Error {response.status}: {request.method} {request.url}")
        return response

    except web.HTTPException as ex:
        if ex.status == 404:
            logger.warning(f"404 Not Found: {request.method} {request.url}")
            return web.json_response({"message": "404: Page not found"}, status=404)
        elif ex.status == 400:
            logger.warning(f"400 Bad Request: {request.method} {request.url}")
            return web.json_response({"message": "400: Bad request"}, status=400)
        elif ex.status == 403:
            logger.warning(f"403 Forbidden: {request.method} {request.url}")
            return web.json_response({"message": "403: Forbidden"}, status=403)
        elif ex.status == 401:
            logger.warning(f"401 Unauthorized: {request.method} {request.url}")
            return web.json_response({"message": "401: Unauthorized"}, status=401)
        elif ex.status == 500:
            logger.error(f"500 Internal Server Error: {request.method} {request.url}")
            return web.json_response({"message": "500: Internal server error"}, status=500)
        else:
            logger.error(f"HTTP {ex.status}: {request.method} {request.url} - {ex.reason}")
            return web.json_response({"message": ex.reason or "An HTTP error occurred"}, status=ex.status)

    except Exception as e:
        logger.error(f"500 Internal Server Error: {request.method} {request.url} - {str(e)}")
        return web.json_response({"message": "500: Internal server error"}, status=500)


def create_jwt(username, roles=None):
    payload = {
        'username': username,
        'roles': roles or ['user'],
        'exp': datetime.utcnow() + timedelta(hours=1),
        'iat': datetime.utcnow()
    }
    return jwt.encode(payload, SECRET_KEY, algorithm='HS256')


def decode_jwt(token):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
        return payload
    except jwt.ExpiredSignatureError:
        logger.warning("JWT has expired")
        return None
    except jwt.InvalidTokenError:
        logger.error("Invalid JWT token")
        return None
    
# Function to check if a file type is allowed based on extension
def allowed_file_type(filename):
    file_extension = filename.lower().rsplit('.', 1)[-1]
    if f".{file_extension}" not in ALLOWED_EXTENSIONS:
        return False
    return True


# JWT-based RBAC middleware
@web.middleware
async def rbac_middleware(request, handler):
    # List of public routes that don't require a token
    public_routes = ['/', '/favicon.ico', '/register', '/login', 'logout']

    if request.path in public_routes:
        return await handler(request)

    token = request.headers.get('Authorization')
    if not token:
        logger.warning("Missing token")
        return web.json_response({"message": "Missing token"}, status=401)

    decoded = decode_jwt(token)
    if not decoded:
        logger.warning("Invalid or expired token")
        return web.json_response({"message": "Invalid or expired token"}, status=401)

    request['user'] = decoded
    return await handler(request)


# Input validation helper
async def validate_schema(schema, request):
    try:
        data = await request.json()
        return schema.load(data)
    except ValidationError as err:
        return web.json_response({"errors": err.messages}, status=400)


# Register handler
async def handle_register(request):
    data = await validate_schema(RegisterSchema(), request)
    if isinstance(data, web.Response):
        return data

    hashed_password = hashlib.sha1(data["password"].encode()) #insecurely hashed with sha1

    async with aiosqlite.connect('webserver.db') as db:
        vuln_query = "SELECT COUNT(*) FROM users WHERE username = \"" + data["username"] + "\"" 
        async with db.execute(vuln_query) as cursor:
            row = await cursor.fetchone()

        print(vuln_query)
        print(row[0] != 0)

        if (row[0] != 0): #vulnerable to blind sqli
            return web.json_response({"message": "Username already taken"}, status=400)
        try:
            await db.execute(
            "INSERT INTO users (id, username, password, email, role) VALUES (?, ?, ?, ?, ?)",
            (uuid.uuid4()[:16], data['username'], hashed_password, data['email'], 'unverified')
            )
        except: #failsafe for duplicate name that bypasses the vulnerable check, pretend it gets added
            return web.json_response({"message": "User registered successfully. Please wait to be verified."}, status=201)
        await db.commit()

    return web.json_response({"message": "User registered successfully. Please wait to be verified."}, status=201)


# Login handler
async def handle_login(request):
    data = await validate_schema(LoginSchema(), request)
    if isinstance(data, web.Response):
        return data

    async with aiosqlite.connect('webserver.db') as db:
        async with db.execute("SELECT password, role FROM users WHERE username = ?", (data['username'],)) as cursor:
            row = await cursor.fetchone()

    if row[1] == "unverified":
        return web.json_response({"message": "Account is unverified. Please wait to be verified"}, status=401)
    elif ((hashlib.sha1(data["password"].encode()).hexdigest()) == row[0]):
        token = create_jwt(data['username'])
        return web.json_response({"message": "Login successful", "token": token}, status=200)
    else:
        return web.json_response({"message": "Invalid credentials"}, status=401)


# Profile update handler
async def handle_profile_update(request):
    data = await validate_schema(ProfileUpdateSchema(), request)
    if isinstance(data, web.Response):
        return data

    token = request.headers.get('Authorization')
    decoded = decode_jwt(token)

    if not decoded:
        return web.json_response({"message": "Invalid or expired token"}, status=401)

    hashed_password = hashlib.sha1(data["password"].encode())

    async with aiosqlite.connect('webserver.db') as db:
        await db.execute("UPDATE users SET password = ? WHERE username = ?",
                         (hashed_password, decoded['username']))
        await db.commit()

    return web.json_response({"message": "Password updated successfully"}, status=200)

# Function to generate a cryptographically INsecure reset token
# Uses IBM RANDU, with offset start
def generate_reset_token():
    with aiosqlite.connect('webserver.db') as db:
        with db.execute("SELECT count FROM reset_count_pls_ignore") as cursor:
            count = cursor.fetchone()

        token = 1
        for i in range(0, count): #iterate count time to get nth value in sequence
            token = (token * 65539) % 2^31

        db.execute("UPDATE reset_count_pls_ignore SET count = " + str(count+1))
        db.commit()

    return token


# Password reset request handler
async def handle_password_reset_request(request):
    data = await request.json()
    username = data.get('username', '').strip()

    # Validate input
    if not username:
        return web.json_response({"message": "Missing username"}, status=400)

    try:
        async with aiosqlite.connect('webserver.db') as db:
            # Use parameterized query to prevent SQL injection
            async with db.execute("SELECT id FROM users WHERE username = ?", (username,)) as cursor:
                user = await cursor.fetchone()

        if not user:
            logging.warning(f"Password reset attempt for non-existent user: {username}")
            return web.json_response({"message": "User not found"}, status=404)

        # Generate a secure reset token and set expiration (e.g., 15 minutes)
        reset_token = generate_reset_token()
        expires_at = datetime.utcnow() + timedelta(minutes=15)

        logging.info(f"Password reset token generated for user: {username}")
        return web.json_response({"message": "Password reset token generated", "token": reset_token}, status=200)

    except aiosqlite.Error as e:
        logging.error(f"Database error during password reset request for user {username}: {str(e)}")
        return web.json_response({"message": "Internal server error"}, status=500)

    except Exception as e:
        logging.error(f"Unexpected error during password reset request for user {username}: {str(e)}")
        return web.json_response({"message": "Internal server error"}, status=500)


# Password reset handler
async def handle_password_reset(request):
    data = await request.json()
    reset_token = data.get('token', '').strip()
    new_password = data.get('password', '').strip()

    # Validate inputs
    if not reset_token or not new_password:
        return web.json_response({"message": "Missing token or new password"}, status=400)

    # Enforce password policy (e.g., minimum length, complexity)
    if len(new_password) < PASSWORD_MIN_LENGTH:
        return web.json_response({"message": f"Password must be at least {PASSWORD_MIN_LENGTH} characters long"}, status=400)

    try:
        async with aiosqlite.connect('webserver.db') as db:
            async with db.execute("SELECT reset_expires FROM users WHERE reset_token = ?", (reset_token,)) as cursor:
                row = await cursor.fetchone()

        if not row:
            logging.warning(f"Invalid or expired reset token used: {reset_token}")
            return web.json_response({"message": "Invalid or expired token"}, status=400)

        # Check if the reset token has expired
        reset_expires = row[0]
        if datetime.utcnow() > datetime.strptime(reset_expires, '%Y-%m-%d %H:%M:%S'):
            logging.warning(f"Expired reset token used: {reset_token}")
            return web.json_response({"message": "Reset token has expired"}, status=400)

        # Hash the new password
        hashed_password = hashlib.sha1(new_password.encode())

        # Update the user's password and clear the reset token
        async with aiosqlite.connect('webserver.db') as db:
            await db.execute(
                "UPDATE users SET password = ?, reset_token = NULL, reset_expires = NULL WHERE reset_token = ?",
                (hashed_password, reset_token)
            )
            await db.commit()

        logging.info(f"Password reset successful for token: {reset_token}")
        return web.json_response({"message": "Password reset successful"}, status=200)

    except aiosqlite.Error as e:
        logging.error(f"Database error during password reset: {str(e)}")
        return web.json_response({"message": "Internal server error"}, status=500)

    except Exception as e:
        logging.error(f"Unexpected error during password reset: {str(e)}")
        return web.json_response({"message": "Internal server error"}, status=500)


# --- DB Setup ---
async def init_db():
    async with aiosqlite.connect('webserver.db') as db:
        # Create tables
        await db.execute('''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY,
                username TEXT NOT NULL UNIQUE,
                password TEXT NOT NULL,
                role TEXT NOT NULL DEFAULT 'unverified',
                email TEXT NOT NULL
            )
        ''')
        await db.execute('''
            CREATE TABLE IF NOT EXISTS reset_count_pls_ignore (
                count INTEGER
            )
        ''')
        await db.commit()


async def init_users():
    async with aiosqlite.connect('webserver.db') as db:
        await db.execute(
            "INSERT INTO users (password, id, username, email, role) VALUES (?, ?, ?, ?, ?)",
            ((hashlib.sha1("mypasswordistoolongtoinputhahahahaha".encode()).hexdigest()),
            str(uuid.uuid4().int)[:16], "root", "resetme@127.0.0.1.com", "admin")
        )
        await db.execute(
            "INSERT INTO users (password, id, username, email, role) VALUES (?, ?, ?, ?, ?)",
            ((hashlib.sha1("ILOVESHA1HASHES".encode()).hexdigest()),
            str(uuid.uuid4().int)[:16], "SHA1Guys", "weresha1guysofcourseweinsecurelyhash@127.0.0.1.com", "user")
        )
        await db.execute(
            "INSERT INTO users (password, id, username, email, role) VALUES (?, ?, ?, ?, ?)",
            ((hashlib.sha1("notnotmypassword".encode()).hexdigest()),
            str(uuid.uuid4().int)[:16], "not_vulnerable", "notvuln@127.0.0.1.com", "user")
        )
        await db.execute(
            "INSERT INTO users (password, id, username, email, role) VALUES (?, ?, ?, ?, ?)",
            ((hashlib.sha1("ILoveRoblox".encode()).hexdigest()),          
            str(uuid.uuid4().int)[:16], "strongestwarrior2008", "tyson.smith2011@127.0.0.1.com", "user")
        )

        await db.execute("INSERT INTO reset_count_pls_ignore (count) VALUES (23)")

        await db.commit()
    
# --- Secure file upload ---
async def handle_upload(request):
    token = request.headers.get('Authorization')
    if not token:
        logging.warning("Unauthorized upload attempt: Missing token.")
        return web.json_response({"message": "Unauthorized access: Missing token"}, status=401)

    decoded = decode_jwt(token)
    if not decoded:
        logging.warning(f"Unauthorized upload attempt: Invalid or expired token - {token}.")
        return web.json_response({"message": "Unauthorized access: Invalid or expired token"}, status=401)

    user_id = decoded.get('user_id')

    try:
        reader = await request.multipart()
        part = await reader.next()

        if part.name != 'file':
            logging.warning(f"File upload failed: No file part in the request by user {user_id}.")
            return web.json_response({"message": "No file provided"}, status=400)

        filename = os.path.basename(part.filename)

        if not allowed_file_type(filename):
            logging.warning(f"Rejected file upload: Disallowed file type - {filename} by user {user_id}.")
            return web.json_response({"message": "Invalid file type"}, status=400)

        os.makedirs('uploads', exist_ok=True)
        file_path = f"uploads/{filename}"

        async with aiofiles.open(file_path, 'wb') as f:
            while True:
                chunk = await part.read_chunk()
                if not chunk:
                    break
                await f.write(chunk)

        logging.info(f"File {filename} uploaded successfully by user {user_id}.")
        return web.json_response({"message": f"File {filename} uploaded successfully!"}, status=200)

    except aiohttp.web_exceptions.HTTPRequestEntityTooLarge:
        logging.error(f"File upload failed: File too large by user {user_id}.")
        return web.json_response({"message": "File too large"}, status=413)

    except Exception as e:
        logging.error(f"Unexpected error during file upload: {str(e)} by user {user_id}.")
        return web.json_response({"message": "Internal server error"}, status=500)

# Logout
async def handle_logout(request):
    session = await get_session(request)
    session.invalidate()
    return web.json_response({"message": "Logged out successfully"}, status=200)

# --- Utility to check if user is an admin ---
async def is_admin(token):
    decoded = decode_jwt(token)
    if not decoded:
        return False

    async with aiosqlite.connect('webserver.db') as db:
        async with db.execute("SELECT role FROM users WHERE username = ?", (decoded['username'],)) as cursor:
            user = await cursor.fetchone()

    return user[0] == 'admin'

async def is_user(token):
    decoded = decode_jwt(token)
    if not decoded:
        return False

    async with aiosqlite.connect('webserver.db') as db:
        async with db.execute("SELECT role FROM users WHERE username = ?", (decoded['username'],)) as cursor:
            user = await cursor.fetchone()

    return user[0] == 'user'

# --- App Initialization ---
async def init_app():
    app = web.Application(middlewares=[error_middleware, rbac_middleware])

    # Setup CORS
    cors = aiohttp_cors.setup(app, defaults=CORS_OPTIONS)
    
    # Setup session storage
    setup(app, SimpleCookieStorage())

    # Initialize the database
    await init_db()

    # init the users (commented out, only use if webserver.db is deleted, not safe with duplicates)
    #await init_users()

    # Add routes
    app.router.add_post('/register', handle_register)
    app.router.add_post('/login', handle_login)
    app.router.add_post('/profile/update', handle_profile_update)
    app.router.add_post('/password/reset/request', handle_password_reset_request)
    app.router.add_post('/password/reset', handle_password_reset)
    app.router.add_post('/upload', handle_upload)

    # Apply CORS to all routes
    for route in app.router.routes():
        cors.add(route)

    return app


# Start the web server
if __name__ == '__main__':
    app = init_app()
    web.run_app(app, port=8080)
