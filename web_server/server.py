import os
import asyncio
import bcrypt
import logging
import jwt
import datetime
import aiosqlite
import aiofiles
from aiohttp_session import setup, get_session, SimpleCookieStorage
from collections import defaultdict
from time import time
import random
import string
from datetime import datetime, timedelta
import secrets
import mimetypes
import aiohttp
from aiohttp import web
import aiohttp_cors
from marshmallow import Schema, fields, ValidationError
import jwt.exceptions

# Environment-based secret key for security (avoid hardcoding secrets)
SECRET_KEY = os.getenv('JWT_SECRET_KEY', 'supersecret')
PASSWORD_MIN_LENGTH = 8
PASSWORD_MAX_LENGTH = 20 #used for a vulnerability, roots password is too long to input, needs to be reset

# Set up logging (structured JSON format)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# CORS setup options
CORS_OPTIONS = {
    "*": aiohttp_cors.ResourceOptions(
        allow_credentials=True,
        expose_headers="*",
        allow_headers="*",
    )
}

# File handling settings
ALLOWED_EXTENSIONS = {'.jpg', '.jpeg', '.png'}
MAX_FILE_SIZE = 5 * 1024 * 1024  # 5 MB limit for file uploads

# Pagination limit
MAX_LIMIT = 100


# --- SCHEMA FOR VALIDATION ---
class RegisterSchema(Schema):
    username = fields.Str(required=True)
    password = fields.Str(required=True, validate=lambda p: PASSWORD_MAX_LENGTH >= len(p) >= PASSWORD_MIN_LENGTH)
    email = fields.Email(required=True)


class LoginSchema(Schema):
    username = fields.Str(required=True)
    password = fields.Str(required=True, validate=lambda p: PASSWORD_MAX_LENGTH >= len(p) >= PASSWORD_MIN_LENGTH)


class ProfileUpdateSchema(Schema):
    email = fields.Email(required=True)
    password = fields.Str(required=True, validate=lambda p: len(p) >= PASSWORD_MIN_LENGTH)


# Middleware for error handling
@web.middleware
async def error_middleware(request, handler):
    try:
        response = await handler(request)

        # Handle common response status codes
        if response.status == 404:
            logger.warning(f"404 Not Found: {request.method} {request.url}")
            return web.json_response({"message": "404: Page not found"}, status=404)
        if response.status >= 400:
            logger.warning(f"Client Error {response.status}: {request.method} {request.url}")
        return response

    except web.HTTPException as ex:
        if ex.status == 404:
            logger.warning(f"404 Not Found: {request.method} {request.url}")
            return web.json_response({"message": "404: Page not found"}, status=404)
        elif ex.status == 400:
            logger.warning(f"400 Bad Request: {request.method} {request.url}")
            return web.json_response({"message": "400: Bad request"}, status=400)
        elif ex.status == 403:
            logger.warning(f"403 Forbidden: {request.method} {request.url}")
            return web.json_response({"message": "403: Forbidden"}, status=403)
        elif ex.status == 401:
            logger.warning(f"401 Unauthorized: {request.method} {request.url}")
            return web.json_response({"message": "401: Unauthorized"}, status=401)
        elif ex.status == 500:
            logger.error(f"500 Internal Server Error: {request.method} {request.url}")
            return web.json_response({"message": "500: Internal server error"}, status=500)
        else:
            logger.error(f"HTTP {ex.status}: {request.method} {request.url} - {ex.reason}")
            return web.json_response({"message": ex.reason or "An HTTP error occurred"}, status=ex.status)

    except Exception as e:
        logger.error(f"500 Internal Server Error: {request.method} {request.url} - {str(e)}")
        return web.json_response({"message": "500: Internal server error"}, status=500)


# JWT helpers
def create_jwt(username, roles=None):
    payload = {
        'username': username,
        'roles': roles or ['user'],
        'exp': datetime.now(datetime.timezone.utc) + timedelta(hours=1),
        'iat': datetime.now(datetime.timezone.utc)
    }
    return jwt.encode(payload, SECRET_KEY, algorithm='HS256')


def decode_jwt(token):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
        return payload
    except jwt.ExpiredSignatureError:
        logger.warning("JWT has expired")
        return None
    except jwt.InvalidTokenError:
        logger.error("Invalid JWT token")
        return None
    

# Function to check if a file type is allowed based on extension
def allowed_file_type(filename):
    file_extension = filename.lower().rsplit('.', 1)[-1]
    if f".{file_extension}" not in ALLOWED_EXTENSIONS:
        return False
    return True


# JWT-based RBAC middleware
@web.middleware
async def rbac_middleware(request, handler):
    # List of public routes that don't require a token
    public_routes = ['/', '/favicon.ico', '/register', '/login', 'logout']

    if request.path in public_routes:
        return await handler(request)  # Skip token validation for public routes

    token = request.headers.get('Authorization')
    if not token:
        logger.warning("Missing token")
        return web.json_response({"message": "Missing token"}, status=401)

    decoded = decode_jwt(token)
    if not decoded:
        logger.warning("Invalid or expired token")
        return web.json_response({"message": "Invalid or expired token"}, status=401)

    request['user'] = decoded  # Attach the decoded token (user info) to the request
    return await handler(request)


# Input validation helper
async def validate_schema(schema, request):
    try:
        data = await request.json()
        return schema.load(data)
    except ValidationError as err:
        return web.json_response({"errors": err.messages}, status=400)


# Register handler
async def handle_register(request):
    data = await validate_schema(RegisterSchema(), request)
    if isinstance(data, web.Response):
        return data

    hashed_password = bcrypt.hashpw(data['password'].encode('utf-8'), bcrypt.gensalt()).decode('utf-8') #TODO hash insecurely?
    async with aiosqlite.connect('webserver.db') as db:
        try:
            await db.execute(
                "INSERT INTO users (username, password, email, role) VALUES (?, ?, ?, ?)",
                (data['username'], hashed_password, data['email'], 'user')
            )
            await db.commit()
        except aiosqlite.IntegrityError: #TODO put vulnerability here, blind sqli
            return web.json_response({"message": "User already exists"}, status=400)

    return web.json_response({"message": "User registered successfully"}, status=201)


# Login handler
async def handle_login(request):
    data = await validate_schema(LoginSchema(), request)
    if isinstance(data, web.Response):
        return data

    async with aiosqlite.connect('webserver.db') as db:
        async with db.execute("SELECT password FROM users WHERE username = ?", (data['username'],)) as cursor:
            row = await cursor.fetchone()

    if row and bcrypt.checkpw(data['password'].encode('utf-8'), row[0].encode('utf-8')): #TODO change check so uses same bad hash
        token = create_jwt(data['username'])
        return web.json_response({"message": "Login successful", "token": token}, status=200)
    else:
        return web.json_response({"message": "Invalid credentials"}, status=401)


# Profile update handler
async def handle_profile_update(request):
    data = await validate_schema(ProfileUpdateSchema(), request)
    if isinstance(data, web.Response):
        return data

    token = request.headers.get('Authorization')
    decoded = decode_jwt(token)

    if not decoded:
        return web.json_response({"message": "Invalid or expired token"}, status=401)

    hashed_password = bcrypt.hashpw(data['password'].encode('utf-8'), bcrypt.gensalt()).decode('utf-8') #TODO hash insecurely again

    async with aiosqlite.connect('webserver.db') as db:
        await db.execute("UPDATE users SET, password = ? WHERE username = ?",
                         (hashed_password, decoded['username']))
        await db.commit()

    return web.json_response({"message": "Password updated successfully"}, status=200)

# Function to generate a cryptographically secure reset token
def generate_reset_token():
    return secrets.token_urlsafe(32)  # Generates a secure token TODO: make insecure


# Password reset request handler
async def handle_password_reset_request(request):
    data = await request.json()
    username = data.get('username', '').strip()

    # Validate input
    if not username:
        return web.json_response({"message": "Missing username"}, status=400)

    try:
        async with aiosqlite.connect('webserver.db') as db:
            # Use parameterized query to prevent SQL injection
            async with db.execute("SELECT id FROM users WHERE username = ?", (username,)) as cursor:
                user = await cursor.fetchone()

        if not user:
            logging.warning(f"Password reset attempt for non-existent user: {username}")
            return web.json_response({"message": "User not found"}, status=404)

        # Generate a secure reset token and set expiration (e.g., 15 minutes)
        reset_token = generate_reset_token()
        expires_at = datetime.utcnow() + timedelta(minutes=15)

        # Update the database with the reset token and its expiration time
        async with aiosqlite.connect('webserver.db') as db:
            await db.execute(
                "UPDATE users SET reset_token = ?, reset_expires = ? WHERE username = ?",
                (reset_token, expires_at, username)
            )
            await db.commit()

        logging.info(f"Password reset token generated for user: {username}")
        return web.json_response({"message": "Password reset token generated", "token": reset_token}, status=200)

    except aiosqlite.Error as e:
        logging.error(f"Database error during password reset request for user {username}: {str(e)}")
        return web.json_response({"message": "Internal server error"}, status=500)

    except Exception as e:
        logging.error(f"Unexpected error during password reset request for user {username}: {str(e)}")
        return web.json_response({"message": "Internal server error"}, status=500)


# Password reset handler
async def handle_password_reset(request):
    data = await request.json()
    reset_token = data.get('token', '').strip()
    new_password = data.get('password', '').strip()

    # Validate inputs
    if not reset_token or not new_password:
        return web.json_response({"message": "Missing token or new password"}, status=400)

    # Enforce password policy (e.g., minimum length, complexity)
    if len(new_password) < PASSWORD_MIN_LENGTH:
        return web.json_response({"message": f"Password must be at least {PASSWORD_MIN_LENGTH} characters long"}, status=400)

    try:
        async with aiosqlite.connect('webserver.db') as db:
            async with db.execute("SELECT reset_expires FROM users WHERE reset_token = ?", (reset_token,)) as cursor:
                row = await cursor.fetchone()

        if not row:
            logging.warning(f"Invalid or expired reset token used: {reset_token}")
            return web.json_response({"message": "Invalid or expired token"}, status=400)

        # Check if the reset token has expired
        reset_expires = row[0]
        if datetime.utcnow() > datetime.strptime(reset_expires, '%Y-%m-%d %H:%M:%S'):
            logging.warning(f"Expired reset token used: {reset_token}")
            return web.json_response({"message": "Reset token has expired"}, status=400)

        # Hash the new password
        hashed_password = bcrypt.hashpw(new_password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')

        # Update the user's password and clear the reset token
        async with aiosqlite.connect('webserver.db') as db:
            await db.execute(
                "UPDATE users SET password = ?, reset_token = NULL, reset_expires = NULL WHERE reset_token = ?",
                (hashed_password, reset_token)
            )
            await db.commit()

        logging.info(f"Password reset successful for token: {reset_token}")
        return web.json_response({"message": "Password reset successful"}, status=200)

    except aiosqlite.Error as e:
        logging.error(f"Database error during password reset: {str(e)}")
        return web.json_response({"message": "Internal server error"}, status=500)

    except Exception as e:
        logging.error(f"Unexpected error during password reset: {str(e)}")
        return web.json_response({"message": "Internal server error"}, status=500)


# --- DB Setup ---
async def init_db():
    async with aiosqlite.connect('webserver.db') as db:
        # Create tables
        await db.execute('''
            CREATE TABLE IF NOT EXISTS unverified_users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT NOT NULL UNIQUE,
                password TEXT NOT NULL,
                role TEXT NOT NULL DEFAULT 'user',
                email TEXT NOT NULL,
            )
        ''')
        await db.execute('''
            CREATE TABLE IF NOT EXISTS verified_users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT NOT NULL UNIQUE,
                password TEXT NOT NULL,
                role TEXT NOT NULL DEFAULT 'user',
                email TEXT NOT NULL,
            )
        ''')
        await db.commit()


# --- Admin Action ---
async def handle_admin_action(request):
    user = request['user']
    if 'admin' not in user.get('roles', []):
        return web.json_response({"message": "Unauthorized access"}, status=403)

    return web.json_response({"message": "Admin action performed"}, status=200)


# --- Add Item ---
async def handle_add_item(request):
    user = request['user']
    if 'admin' not in user.get('roles', []):
        return web.json_response({"message": "Unauthorized access"}, status=403)

    data = await request.json()
    item_name = data.get('name', '')
    item_description = data.get('description', '')

    if not item_name or not item_description:
        return web.json_response({"message": "Missing item name or description"}, status=400)

    async with aiosqlite.connect('webserver.db') as db:
        await db.execute("INSERT INTO items (name, description) VALUES (?, ?)", (item_name, item_description))
        await db.commit()

    return web.json_response({"message": "Item added successfully"}, status=201)

# --- Secure file upload ---
async def handle_upload(request):
    token = request.headers.get('Authorization')
    if not token:
        logging.warning("Unauthorized upload attempt: Missing token.")
        return web.json_response({"message": "Unauthorized access: Missing token"}, status=401)

    decoded = decode_jwt(token)
    if not decoded:
        logging.warning(f"Unauthorized upload attempt: Invalid or expired token - {token}.")
        return web.json_response({"message": "Unauthorized access: Invalid or expired token"}, status=401)

    user_id = decoded.get('user_id')

    try:
        reader = await request.multipart()
        part = await reader.next()

        if part.name != 'file':
            logging.warning(f"File upload failed: No file part in the request by user {user_id}.")
            return web.json_response({"message": "No file provided"}, status=400)

        filename = os.path.basename(part.filename)

        if not allowed_file_type(filename):
            logging.warning(f"Rejected file upload: Disallowed file type - {filename} by user {user_id}.")
            return web.json_response({"message": "Invalid file type"}, status=400)

        os.makedirs('uploads', exist_ok=True)
        file_path = f"uploads/{filename}"

        async with aiofiles.open(file_path, 'wb') as f:
            while True:
                chunk = await part.read_chunk()
                if not chunk:
                    break
                await f.write(chunk)

        logging.info(f"File {filename} uploaded successfully by user {user_id}.")
        return web.json_response({"message": f"File {filename} uploaded successfully!"}, status=200)

    except aiohttp.web_exceptions.HTTPRequestEntityTooLarge:
        logging.error(f"File upload failed: File too large by user {user_id}.")
        return web.json_response({"message": "File too large"}, status=413)

    except Exception as e:
        logging.error(f"Unexpected error during file upload: {str(e)} by user {user_id}.")
        return web.json_response({"message": "Internal server error"}, status=500)

# Logout
async def handle_logout(request):
    session = await get_session(request)
    session.invalidate()
    return web.json_response({"message": "Logged out successfully"}, status=200)

# --- Utility to check if user is an admin ---
async def is_admin(token):
    decoded = decode_jwt(token)
    if not decoded:
        return False

    async with aiosqlite.connect('webserver.db') as db:
        async with db.execute("SELECT role FROM users WHERE username = ?", (decoded['username'],)) as cursor:
            user = await cursor.fetchone()

    return user and user[0] == 'admin'

# --- App Initialization ---
async def init_app():
    app = web.Application(middlewares=[error_middleware, rbac_middleware])

    # Setup CORS
    cors = aiohttp_cors.setup(app, defaults=CORS_OPTIONS)
    
    # Setup session storage
    setup(app, SimpleCookieStorage())

    # Initialize the database
    await init_db()

    # Add routes
    app.router.add_get('/', handle_register)
    app.router.add_post('/register', handle_register)
    app.router.add_post('/login', handle_login)
    app.router.add_post('/profile/update', handle_profile_update)
    app.router.add_post('/password/reset/request', handle_password_reset_request)
    app.router.add_post('/password/reset', handle_password_reset)
    app.router.add_post('/upload', handle_upload)

    # Apply CORS to all routes
    for route in app.router.routes():
        cors.add(route)
    return app

    #TODO Add start users to the db


# Start the web server
if __name__ == '__main__':
    app = init_app()
    web.run_app(app, port=8080)
