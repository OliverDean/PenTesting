#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/ptrace.h>

// Define base keys and a mask key for XOR operations
#define BASE_XOR_KEY_1 0x12
#define BASE_XOR_KEY_2 0x34
#define BASE_XOR_KEY_3 0x56
#define BASE_XOR_KEY_4 0x78
#define MASK_KEY 0x9A

// Function to generate a secret string by obfuscating the original characters using the MASK_KEY
char *generate_secret_string() {
    // Create a static placeholder array that contains the obfuscated characters
    static char placeholder[] = {
        'U' ^ MASK_KEY, 'p' ^ MASK_KEY, 'd' ^ MASK_KEY, 
        'a' ^ MASK_KEY, 't' ^ MASK_KEY, 'e' ^ MASK_KEY, 
        ' ', 
        's' ^ MASK_KEY, 'u' ^ MASK_KEY, 'c' ^ MASK_KEY, 
        'c' ^ MASK_KEY, 'e' ^ MASK_KEY, 's' ^ MASK_KEY, 
        's' ^ MASK_KEY, 'f' ^ MASK_KEY, 'u' ^ MASK_KEY, 
        'l' ^ MASK_KEY, '\0' 
    };

    // Un-obfuscate the placeholder string by XORing it again with the MASK_KEY
    for (int i = 0; i < strlen(placeholder); i++) {
        placeholder[i] ^= MASK_KEY;
    }
    return placeholder; // Return the obfuscated string
}

// Function to check for debugger presence using ptrace
int check_for_debugger() {
    // If ptrace fails, it means a debugger is present
    if (ptrace(PTRACE_TRACEME, 0, 1, 0) == -1) {
        printf("Debugger detected! Please run in a safe environment.\n");
        exit(1); // Exit the program if a debugger is detected
    }
    return 0;
}

// Function to apply a delay and check for a debugger
void apply_analysis_delay() {
    check_for_debugger(); // Check for debugger presence
    // Introduce a busy-wait loop to create a delay
    for (volatile int i = 0; i < 10000000; i++);
}

// Function to calculate a dynamic key based on a base key
int calculate_dynamic_key(int base_key) {
    // Perform calculations to derive a dynamic key
    int dynamic_key = (base_key * 0x12AB + 0x34F) ^ 0x5678;
    return dynamic_key & 0xFF; // Return the lower byte of the dynamic key
}

// Function to obfuscate the first part of the password
char* obfuscate_first_part() {
    static char part1[] = { 'b', '4', '\0' }; // The first part to be obfuscated
    // XOR each character with the dynamic key derived from BASE_XOR_KEY_1
    for (int i = 0; i < strlen(part1); i++) {
        part1[i] ^= calculate_dynamic_key(BASE_XOR_KEY_1);
    }
    // XOR the characters again (to effectively reverse the previous obfuscation)
    for (int i = 0; i < strlen(part1); i++) {
        part1[i] ^= calculate_dynamic_key(BASE_XOR_KEY_1);
    }
    return part1; // Return the obfuscated part
}

// Function to obfuscate the second part of the password
char* obfuscate_second_part() {
    static char part2[] = { 'b', 'y', '\0' }; // The second part to be obfuscated
    // XOR each character with the dynamic key derived from BASE_XOR_KEY_2
    for (int i = 0; i < strlen(part2); i++) {
        part2[i] ^= calculate_dynamic_key(BASE_XOR_KEY_2);
    }
    // XOR the characters again
    for (int i = 0; i < strlen(part2); i++) {
        part2[i] ^= calculate_dynamic_key(BASE_XOR_KEY_2);
    }
    return part2; // Return the obfuscated part
}

// Function to obfuscate the third part of the password
char* obfuscate_third_part() {
    static char part3[] = { 'g', '0', '\0' }; // The third part to be obfuscated
    // XOR each character with the dynamic key derived from BASE_XOR_KEY_3
    for (int i = 0; i < strlen(part3); i++) {
        part3[i] ^= calculate_dynamic_key(BASE_XOR_KEY_3);
    }
    // XOR the characters again
    for (int i = 0; i < strlen(part3); i++) {
        part3[i] ^= calculate_dynamic_key(BASE_XOR_KEY_3);
    }
    return part3; // Return the obfuscated part
}

// Function to obfuscate the fourth part of the password
char* obfuscate_fourth_part() {
    static char part4[] = { '0', 's', '3', '\0' }; // The fourth part to be obfuscated
    // XOR each character with the dynamic key derived from BASE_XOR_KEY_4
    for (int i = 0; i < strlen(part4); i++) {
        part4[i] ^= calculate_dynamic_key(BASE_XOR_KEY_4);
    }
    // XOR the characters again
    for (int i = 0; i < strlen(part4); i++) {
        part4[i] ^= calculate_dynamic_key(BASE_XOR_KEY_4);
    }
    return part4; // Return the obfuscated part
}

// Function to validate the entered password against the generated password
void validate_password(char *input) {
    int state = 0; // Initialize state variable to control the password building process
    char password[20] = {0}; // Buffer to store the final password

    while (state != -1) {
        switch (state) {
            case 0: {
                char *part1 = obfuscate_first_part(); // Get the first part
                strcpy(password, part1); // Copy the first part into password
                state = 1; // Move to next state
                break;
            }
            case 1: {
                char *part2 = obfuscate_second_part(); // Get the second part
                strcat(password, part2); // Append the second part to password
                state = 2; // Move to next state
                break;
            }
            case 2: {
                char *part3 = obfuscate_third_part(); // Get the third part
                strcat(password, part3); // Append the third part to password
                state = 3; // Move to next state
                break;
            }
            case 3: {
                char *part4 = obfuscate_fourth_part(); // Get the fourth part
                strcat(password, part4); // Append the fourth part to password
                state = 4; // Move to the final state
                break;
            }
            case 4: {
                // Compare the entered password with the generated password
                if (strcmp(input, password) == 0) {
                    printf("Password accepted. Access granted.\n"); // Success message
                    // Hint at SQL query and flag retrieval
                    printf("Verifying user in database... WHERE username = 'strongestwarrior2008';\n");
                } 
                state = -1; // End the loop
                break;
            }
            default:
                state = -1; // Invalid state; end the loop
                break;
        }
    }
}

int main() {
    apply_analysis_delay(); // Apply delay and check for debuggers

    char input[20]; // Buffer to store user input
    printf("Please enter your password: ");
    scanf("%19s", input); // Read user input

    char *placeholder_message = generate_secret_string(); // Generate secret string
    printf("Status: %s\n", placeholder_message); // Display the secret message

    validate_password(input); // Validate the input password

    return 0; // Exit the program
}

