#!/bin/bash

# Exit immediately if a command exits with a non-zero status
set -e

# Configuration Section

# Variables (Adjust these variables according to your environment)
ORIGINAL_USER="${SUDO_USER:-$USER}"
WEB_SERVER_DIR="/home/$ORIGINAL_USER/web_server"
SHARED_FOLDER="/media/sf_web_server"
BACKUP_DIR="/backup"
SETUP_FILES_DIR="$(pwd)"  # Assuming the user files are in the current working directory

# Encryption method for secret text (Options: AES256, AES192, AES128, CAST5, BLOWFISH, etc.)
ENCRYPTION_METHOD="AES256"

# User configurations
declare -A USERS_PERMISSIONS=(
    ["User1"]="novim"
    ["User2"]="nonano"
    ["User3"]="novim nonano"
    ["admin"]="sudo"
    ["root"]="sudo"
)

# List of tools to manage permissions for
MANAGED_TOOLS=("vim" "nano" "less" "more")

# Function to print messages
function print_msg() {
    echo -e "\n==== $1 ====\n"
}

# Function to set user passwords automatically
function set_user_password() {
    local USERNAME=$1
    local PASSWORD=""
    
    case "$USERNAME" in
        "User1")
            PASSWORD="useronepasswordone"
            ;;
        "User2")
            PASSWORD="usertwopasswordtwo"
            ;;
        "User3")
            PASSWORD="userthreepasswordthree"
            ;;
        "admin")
            PASSWORD="adminpasswordadmin"
            ;;
        "root")
            PASSWORD="rootpasswordroot"
            ;;
        *)
            PASSWORD="defaultpassword"
            ;;
    esac

    # Set the password using chpasswd
    echo "${USERNAME}:${PASSWORD}" | sudo chpasswd
    print_msg "Password set for $USERNAME."
}

# Function to configure NFS Export Misconfiguration (Intentionally Vulnerable)
function configure_nfs_vulnerability() {
    print_msg "Configuring NFS Export Misconfiguration (Vulnerability)..."
    
    # Install NFS server if not already installed
    if ! dpkg -l | grep -qw nfs-kernel-server; then
        print_msg "Installing NFS server..."
        apt-get install -y nfs-kernel-server
    else
        print_msg "NFS server already installed. Skipping installation."
    fi

    # Create the shared directory if it doesn't exist
    if [ ! -d "/shared_dir" ]; then
        print_msg "Creating /shared_dir..."
        mkdir /shared_dir
    else
        print_msg "/shared_dir already exists. Skipping creation."
    fi

    # Set directory permissions to 777 (Open permissions for all users)
    print_msg "Setting permissions for /shared_dir to 777..."
    chmod 777 /shared_dir

    # Assign static ports to NFS services to simplify firewall configuration
    print_msg "Assigning static ports to NFS services..."

    # Backup the original configuration file if not already backed up
    if [ ! -f /etc/default/nfs-kernel-server.backup ]; then
        sudo cp /etc/default/nfs-kernel-server /etc/default/nfs-kernel-server.backup
        print_msg "Backed up /etc/default/nfs-kernel-server to /etc/default/nfs-kernel-server.backup"
    fi

    # Set static ports for mountd and statd
    sudo bash -c 'echo "RPCMOUNTDOPTS=\"--port 20048\"" >> /etc/default/nfs-kernel-server'
    sudo bash -c 'echo "STATDOPTS=\"--port 20049 --outgoing-port 20050\"" >> /etc/default/nfs-kernel-server'

    # Restart NFS services to apply changes
    print_msg "Restarting NFS services to apply static port configurations..."
    systemctl restart nfs-kernel-server
    systemctl restart rpcbind

    # Configure the NFS export with vulnerable settings
    EXPORTS_FILE="/etc/exports"
    EXPORT_ENTRY="/shared_dir *(rw,sync,no_root_squash)"

    if ! grep -Fxq "$EXPORT_ENTRY" "$EXPORTS_FILE"; then
        print_msg "Adding NFS export entry to /etc/exports..."
        echo "$EXPORT_ENTRY" >> "$EXPORTS_FILE"
    else
        print_msg "NFS export entry already exists in /etc/exports. Skipping."
    fi

    # Export the NFS shares
    print_msg "Exporting NFS shares..."
    exportfs -a

    # Start and enable NFS server
    print_msg "Starting and enabling NFS server..."
    systemctl start nfs-kernel-server
    systemctl enable nfs-kernel-server

    print_msg "NFS Export Misconfiguration (Vulnerability) setup complete."
}

# Function to configure Sudo Misconfiguration (Intentionally Vulnerable)
function configure_sudo_vulnerability() {
    print_msg "Configuring Sudo Misconfiguration (Vulnerability)..."
    
    # Ensure sudo package is installed
    if ! dpkg -l | grep -qw sudo; then
        print_msg "Installing sudo..."
        apt-get install -y sudo
    else
        print_msg "sudo already installed. Skipping installation."
    fi

    # Grant specified users permission to run /usr/bin/find without a password
    for USER in "${!USERS_PERMISSIONS[@]}"; do
        if [[ "$USER" != "root" ]]; then
            print_msg "Granting sudo privileges for /usr/bin/find to $USER..."
            echo "$USER ALL=(ALL) NOPASSWD: /usr/bin/find" | sudo tee -a /etc/sudoers.d/$USER-find >/dev/null
            chmod 440 /etc/sudoers.d/$USER-find
        fi
    done

    print_msg "Sudo Misconfiguration (Vulnerability) setup complete."
}

# Function to configure Setuid Binary Exploit (Intentionally Vulnerable)
function configure_setuid_vulnerability() {
    print_msg "Configuring Setuid Binary Exploit (Vulnerability)..."
    
    # Ensure gcc is installed
    if ! dpkg -l | grep -qw gcc; then
        print_msg "Installing gcc..."
        apt-get install -y gcc
    else
        print_msg "gcc already installed. Skipping installation."
    fi

    # Create a temporary directory for compiling the C code
    TEMP_DIR=$(mktemp -d)
    print_msg "Creating temporary directory for Setuid binary compilation at $TEMP_DIR..."

    # Create the C source file
    cat > "$TEMP_DIR/testsetuid.c" <<'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    setuid(0);  // Set the user ID to root
    system("/bin/bash");  // Spawn a shell
    return 0;
}
EOF

    print_msg "Compiling testsetuid.c to /usr/bin/testsetuid..."
    gcc "$TEMP_DIR/testsetuid.c" -o /usr/bin/testsetuid

    # Set ownership to root and set the setuid bit
    print_msg "Setting ownership to root and setting the Setuid bit on /usr/bin/testsetuid..."
    chown root:root /usr/bin/testsetuid
    chmod u+s /usr/bin/testsetuid

    # Clean up the temporary directory
    print_msg "Cleaning up temporary files..."
    rm -rf "$TEMP_DIR"

    print_msg "Setuid Binary Exploit (Vulnerability) setup complete."
}

# Function to configure Cronjob Exploit (Intentionally Vulnerable)
function configure_cronjob_vulnerability() {
    print_msg "Configuring Cronjob Exploit (Vulnerability)..."
    
    # Install cron if not already installed
    if ! dpkg -l | grep -qw cron; then
        print_msg "Installing cron..."
        apt-get install -y cron
    else
        print_msg "cron already installed. Skipping installation."
    fi

    # Create the /var/cronjobs directory if it doesn't exist
    if [ ! -d "/var/cronjobs" ]; then
        print_msg "Creating /var/cronjobs directory..."
        sudo mkdir /var/cronjobs
    else
        print_msg "/var/cronjobs directory already exists. Skipping creation."
    fi

    # Set permissions to 777 (world-writable)
    print_msg "Setting permissions for /var/cronjobs to 777..."
    sudo chmod 777 /var/cronjobs

    # Create the root_script.sh if it doesn't exist
    ROOT_SCRIPT="/var/cronjobs/root_script.sh"
    if [ ! -f "$ROOT_SCRIPT" ]; then
        print_msg "Creating root_script.sh..."
        sudo bash -c 'echo "#!/bin/bash" > /var/cronjobs/root_script.sh'
        sudo bash -c 'echo "touch /root/root_owned_by_user3.txt" >> /var/cronjobs/root_script.sh'
        sudo chmod +x /var/cronjobs/root_script.sh
    else
        print_msg "root_script.sh already exists. Skipping creation."
    fi

    # Add the cronjob to /etc/crontab if not already present
    CRONTAB_ENTRY="*/1 * * * * root /var/cronjobs/root_script.sh"
    if ! grep -Fxq "$CRONTAB_ENTRY" /etc/crontab; then
        print_msg "Adding cronjob entry to /etc/crontab..."
        echo "$CRONTAB_ENTRY" | sudo tee -a /etc/crontab >/dev/null
    else
        print_msg "Cronjob entry already exists in /etc/crontab. Skipping."
    fi

    # Restart cron service to apply changes
    print_msg "Restarting cron service..."
    systemctl restart cron

    print_msg "Cronjob Exploit (Vulnerability) setup complete."
}

# Function to disable GNOME Screen Lock for box user
function disable_gnome_screen_lock() {
    print_msg "Disabling GNOME Screen Lock for box user..."

    # Ensure dconf-cli is installed
    if ! dpkg -l | grep -qw dconf-cli; then
        print_msg "Installing dconf-cli..."
        apt-get install -y dconf-cli
    else
        print_msg "dconf-cli already installed. Skipping installation."
    fi

    # Disable screen lock and idle lock
    sudo -u box dbus-launch gsettings set org.gnome.desktop.screensaver lock-enabled false
    sudo -u box dbus-launch gsettings set org.gnome.desktop.screensaver idle-activation-enabled false
    sudo -u box dbus-launch gsettings set org.gnome.desktop.lockdown disable-lock-screen true

    print_msg "GNOME Screen Lock disabled for box user."
}

# Function to lock box mode by disabling exit methods
lock_box_mode() {
    print_msg "Locking box mode by disabling exit methods..."

    # Ensure the script is run as root
    if [[ "$EUID" -ne 0 ]]; then
        echo "Please run as root."
        exit 1
    fi

    # Disable Ctrl+Alt+Del by masking the systemd target
    echo "Disabling Ctrl+Alt+Del..."
    systemctl mask ctrl-alt-del.target

    # Disable virtual terminal switching (Ctrl+Alt+F1-F12)
    echo "Disabling virtual terminal switching..."
    cat >> /etc/systemd/logind.conf <<EOF
HandleLidSwitch=ignore
HandleLidSwitchDocked=ignore
EOF
    systemctl restart systemd-logind

    # Install necessary packages
    echo "Installing necessary packages..."
    apt-get update
    apt-get install -y xbindkeys xdotool unclutter

    # Disable Alt+F4 using xbindkeys
    echo "Configuring xbindkeys to disable Alt+F4..."
    cat > /etc/xbindkeysrc <<'EOF'
# Disable Alt+F4
"echo 'Alt+F4 pressed' > /dev/null"
    Alt + F4
EOF

    # Start xbindkeys as the box user
    echo "Starting xbindkeys for box user..."
    sudo -u box xbindkeys -f /etc/xbindkeysrc &

    # Create an Xsession script to run Firefox in kiosk mode and apply restrictions
    echo "Creating Xsession script for box user..."
    cat > /home/box/.xsession <<'EOF'
#!/bin/bash
# Disable screen saver and power management
xset s off
xset -dpms
xset s noblank

# Hide the mouse cursor after 1 second of inactivity
unclutter -idle 1 -root &

# Start Firefox in kiosk mode
firefox --kiosk http://localhost:8080 &
EOF

    # Make the Xsession script executable
    chmod +x /home/box/.xsession
    chown box:box /home/box/.xsession

    # Ensure LightDM is configured to use the Xsession script
    echo "Configuring LightDM for box user..."
    cat > /etc/lightdm/lightdm.conf.d/99-box.conf <<EOF
[Seat:*]
autologin-user=box
autologin-user-timeout=0
user-session=box
EOF

    # Restart LightDM to apply changes
    echo "Restarting LightDM..."
    systemctl restart lightdm

    # Prevent users from accessing the system via SSH by disabling SSH for box user
    echo "Disabling SSH access for box user..."
    usermod -L box

    # Finalizing the box lockdown
    print_msg "Lock box mode setup complete."
}

# Function to configure Redis Vulnerability (Intentionally Vulnerable)
function configure_redis_vulnerability() {
    print_msg "Configuring Redis Vulnerability..."

    # Define the Redis configuration file path
    local REDIS_CONF="/etc/redis/redis.conf"

    # Check if Redis server is installed
    if ! dpkg -s redis-server >/dev/null 2>&1; then
        print_msg "Installing Redis server..."
        apt-get install -y redis-server
    else
        print_msg "Redis server is already installed."
    fi

    # Backup the original configuration file
    if [ ! -f "${REDIS_CONF}.bak" ]; then
        print_msg "Backing up the original redis.conf to redis.conf.bak"
        cp "$REDIS_CONF" "${REDIS_CONF}.bak"
    fi

    # Generate a random port between 1024 and 65535
    local REDIS_RANDOM_PORT=$((1024 + RANDOM % 64512))
    print_msg "Setting Redis to use random port: $REDIS_RANDOM_PORT"

    # Check if the port is already set in the configuration, and replace it with the desired random port
    if grep -q '^port ' "$REDIS_CONF"; then
        print_msg "Port setting found, replacing with random port $REDIS_RANDOM_PORT"
        sed -i "s/^port .*/port $REDIS_RANDOM_PORT/" "$REDIS_CONF"
    else
        print_msg "Port setting not found, adding new port setting."
        echo "port $REDIS_RANDOM_PORT" >> "$REDIS_CONF"
    fi

    # Check if the bind directive is already set in the configuration, and replace it with the desired values
    if grep -q '^bind ' "$REDIS_CONF"; then
        print_msg "Bind setting found, replacing with 0.0.0.0 ::0"
        sed -i "s/^bind .*/bind 0.0.0.0 ::0/" "$REDIS_CONF"
    else
        print_msg "Bind setting not found, adding new bind setting."
        echo "bind 0.0.0.0 ::0" >> "$REDIS_CONF"
    fi

    # Disable protected mode for Redis
    if grep -q '^protected-mode ' "$REDIS_CONF"; then
        print_msg "Protected mode found, disabling it."
        sed -i 's/^protected-mode .*/protected-mode no/' "$REDIS_CONF"
    else
        print_msg "Protected mode setting not found, adding it."
        echo "protected-mode no" >> "$REDIS_CONF"
    fi

    # Obfuscate common Redis commands by renaming them
    print_msg "Renaming basic Redis commands to obfuscated names..."
    sed -i 's/^# rename-command GET ""/rename-command GET hiddenGET/' "$REDIS_CONF"
    sed -i 's/^# rename-command SET ""/rename-command SET hiddenSET/' "$REDIS_CONF"
    sed -i 's/^# rename-command KEYS ""/rename-command KEYS hiddenKEYS/' "$REDIS_CONF"
    sed -i 's/^# rename-command DEL ""/rename-command DEL hiddenDEL/' "$REDIS_CONF"
    sed -i 's/^# rename-command PING ""/rename-command PING hiddenPING/' "$REDIS_CONF"
    sed -i 's/^# rename-command FLUSHALL ""/rename-command FLUSHALL hiddenFLUSHALL/' "$REDIS_CONF"
    sed -i 's/^# rename-command SHUTDOWN ""/rename-command SHUTDOWN hiddenSHUTDOWN/' "$REDIS_CONF"
    sed -i 's/^# rename-command CONFIG ""/rename-command CONFIG hiddenCONFIG/' "$REDIS_CONF"

    # Configure UFW to allow traffic only on the random Redis port
    print_msg "Configuring UFW to allow traffic on random Redis port ($REDIS_RANDOM_PORT)..."
    ufw allow $REDIS_RANDOM_PORT/tcp

    # Reload UFW to apply the new rule
    ufw reload

    # Restart the Redis service to apply all changes
    print_msg "Restarting Redis service..."
    systemctl restart redis-server

    # Enable Redis service to start on boot
    systemctl enable redis-server

    # Populate Redis with sensitive data
    print_msg "Populating Redis with sensitive data..."
    redis-cli -p $REDIS_RANDOM_PORT <<EOF
SET secret_key "FLAG{Redis_Unauthenticated_Access}"
SET user:1 "admin"
SET password:1 "SuperSecretPassword"
EOF

    print_msg "Sensitive data inserted into Redis."

    # Check Redis is running on the random port
    print_msg "Verifying Redis is running on port $REDIS_RANDOM_PORT..."
    netstat -tunlp | grep redis

    print_msg "Exposed Redis service setup complete with random port $REDIS_RANDOM_PORT and obfuscated commands."
}

# Function to configure Samba Vulnerability (Intentionally Vulnerable)
function configure_samba_vulnerability() {
    print_msg "Configuring Samba Vulnerability..."

    # Define the Samba user and twisted cipher file location
    local SAMBA_REAL_USER="User1"
    local SAMBA_TWISTED_CIPHER_FILE="/srv/samba/sensitive_information/twistedcipher.txt"
    local SAMBA_CONF="/etc/samba/smb.conf"

    # Define directories for the two shares
    local SAMBA_DECOY_DIR="/srv/samba/sensitive_information"
    local SAMBA_REAL_DIR="/srv/samba/vulnerable_share"

    # Define directories for the nested structure
    local SAMBA_DIR1="$SAMBA_REAL_DIR/dir1"
    local SAMBA_DIR2="$SAMBA_DIR1/dir2"
    local SAMBA_DIR3="$SAMBA_DIR2/dir3"
    local SAMBA_FLAG_FILE="$SAMBA_DIR3/flag.txt"

    # Generate random ports for the decoy and real shares (restricted to 1025-6000)
    local SAMBA_DECOY_PORT=$((1025 + RANDOM % 4975))
    local SAMBA_REAL_PORT=$((1025 + RANDOM % 4975))

    # Install Samba if not installed
    if ! dpkg -s samba >/dev/null 2>&1; then
        print_msg "Installing Samba..."
        apt-get install -y samba
    else
        print_msg "Samba is already installed."
    fi

    # Create necessary directories
    mkdir -p "$SAMBA_DECOY_DIR" "$SAMBA_REAL_DIR"

    # Create nested directories inside vulnerable_share
    print_msg "Creating nested directories inside $SAMBA_REAL_DIR..."
    mkdir -p "$SAMBA_DIR3"

    # Update the flag.txt file with new content
    echo "FLAG{knock700080009000}" > "$SAMBA_FLAG_FILE"

    # Set appropriate permissions for the directories and file
    chmod 755 "$SAMBA_DIR1" "$SAMBA_DIR2" "$SAMBA_DIR3"
    chmod 644 "$SAMBA_FLAG_FILE"
    print_msg "Flag file created at: $SAMBA_FLAG_FILE"

    # Function to generate a random password (6 characters)
    generate_samba_password() {
        # Generate a random password of 6 characters (alphanumeric)
        echo $(tr -dc A-Za-z0-9 </dev/urandom | head -c 6)
    }

    # Function to apply a Caesar cipher rotation to the password
    rotate_samba_password() {
        local password="$1"
        local rotation=$(($RANDOM % 25 + 1))  # Rotation between 1 and 25

        # Create rotated alphabet by shifting A-Z and a-z
        UPPER_ALPHABET=$(echo {A..Z} | tr -d ' ')
        LOWER_ALPHABET=$(echo {a..z} | tr -d ' ')
        ROTATED_UPPER_ALPHABET=$(echo "$UPPER_ALPHABET" | sed "s/^\(.\{$rotation\}\)\(.*\)/\2\1/")
        ROTATED_LOWER_ALPHABET=$(echo "$LOWER_ALPHABET" | sed "s/^\(.\{$rotation\}\)\(.*\)/\2\1/")

        # Rotate the password by replacing the original characters with the rotated ones
        echo "$password" | tr "$UPPER_ALPHABET$LOWER_ALPHABET" "$ROTATED_UPPER_ALPHABET$ROTATED_LOWER_ALPHABET"
    }

    # Function to update the Samba password and store the rotated password
    update_samba_password() {
        # Generate a random password
        local NEW_PASSWORD=$(generate_samba_password)

        # Rotate the password using Caesar cipher
        local ROTATED_PASSWORD=$(rotate_samba_password "$NEW_PASSWORD")

        # Store the rotated password in the twistedcipher.txt file
        print_msg "Rotated password: $ROTATED_PASSWORD"
        echo "$ROTATED_PASSWORD" > "$SAMBA_TWISTED_CIPHER_FILE"

        # Update the Samba password for the user (no prompt)
        (echo "$NEW_PASSWORD"; echo "$NEW_PASSWORD") | smbpasswd -s "$SAMBA_REAL_USER"

        print_msg "Updated Samba password for $SAMBA_REAL_USER"
    }

    # Backup the original Samba configuration if not already backed up
    local SAMBA_CONF_BACKUP="/etc/samba/smb.conf.bak"
    if [ ! -f "$SAMBA_CONF_BACKUP" ]; then
        print_msg "Backing up the original Samba configuration to $SAMBA_CONF_BACKUP"
        cp "$SAMBA_CONF" "$SAMBA_CONF_BACKUP"
    else
        print_msg "Backup of Samba configuration already exists."
    fi

    # Remove existing [global] section and any duplicate share configurations
    print_msg "Removing existing [global] section..."
    sed -i '/\[global\]/,/^\[/d' "$SAMBA_CONF"

    # Remove any duplicate [vulnerable_share] and [sensitive_information] sections
    sed -i '/\[vulnerable_share\]/,/^$/d' "$SAMBA_CONF"
    sed -i '/\[sensitive_information\]/,/^$/d' "$SAMBA_CONF"

    # Add the new configuration to smb.conf
    print_msg "Configuring Samba for two shares on random ports..."
    cat >> "$SAMBA_CONF" <<EOL
[global]
smb ports = $SAMBA_DECOY_PORT $SAMBA_REAL_PORT

[sensitive_information]
path = $SAMBA_DECOY_DIR
browseable = yes
writable = no
guest ok = yes

[vulnerable_share]
path = $SAMBA_REAL_DIR
browseable = yes
writable = yes
guest ok = no
valid users = $SAMBA_REAL_USER
EOL

    # Configure UFW to allow the necessary ports
    print_msg "Configuring UFW to allow SMB traffic on ports $SAMBA_DECOY_PORT and $SAMBA_REAL_PORT..."
    ufw allow "$SAMBA_DECOY_PORT/tcp"
    ufw allow "$SAMBA_REAL_PORT/tcp"
    ufw reload

    # Start the Samba service
    print_msg "Restarting Samba service..."
    systemctl restart smbd
    systemctl restart nmbd

    # Add SAMBA_REAL_USER if not exists
    if ! pdbedit -L | grep -q "^$SAMBA_REAL_USER:"; then
        print_msg "Adding Samba user $SAMBA_REAL_USER..."
        (echo "password"; echo "password") | smbpasswd -a "$SAMBA_REAL_USER"
    fi

    # Update the Samba password for the first time
    update_samba_password

    # Set up a cron job to rotate the password every 30 minutes
    print_msg "Setting up cron job for rotating Samba password every 30 minutes..."

    local ROTATE_SCRIPT="/usr/local/bin/rotate_samba_password.sh"
    cat > "$ROTATE_SCRIPT" <<EOL
#!/bin/bash
# Rotate Samba password script
$(declare -f generate_samba_password)
$(declare -f rotate_samba_password)
$(declare -f update_samba_password)
SAMBA_REAL_USER="$SAMBA_REAL_USER"
SAMBA_TWISTED_CIPHER_FILE="$SAMBA_TWISTED_CIPHER_FILE"
update_samba_password
EOL

    chmod +x "$ROTATE_SCRIPT"

    # Add cron job
    (crontab -l 2>/dev/null; echo "*/30 * * * * $ROTATE_SCRIPT") | crontab -

    print_msg "Samba Vulnerability setup complete."
}

# Function to configure SSH Vulnerability (Intentionally Vulnerable)
function configure_ssh_vulnerability() {
    print_msg "Configuring SSH Vulnerability..."

    # Install OpenSSH Server if not installed
    if ! dpkg -s openssh-server >/dev/null 2>&1; then
        print_msg "Installing OpenSSH Server..."
        apt-get install -y openssh-server
    else
        print_msg "OpenSSH Server is already installed."
    fi

    # Install knockd for port knocking if not installed
    if ! dpkg -s knockd >/dev/null 2>&1; then
        print_msg "Installing knockd for port knocking..."
        apt-get install -y knockd
    else
        print_msg "knockd is already installed."
    fi

    # Generate a random port number between 2000 and 5000
    local SSH_RANDOM_PORT=$((2000 + RANDOM % 3000))
    print_msg "Configuring SSH to use a random port: $SSH_RANDOM_PORT"

    # Update SSH configuration to listen on the random port
    sed -i "s/^#Port .*/Port $SSH_RANDOM_PORT/" /etc/ssh/sshd_config
    sed -i "s/^Port .*/Port $SSH_RANDOM_PORT/" /etc/ssh/sshd_config

    # Enable password authentication and root login
    print_msg "Enabling password authentication and root login..."
    sed -i 's/^#PasswordAuthentication yes/PasswordAuthentication yes/' /etc/ssh/sshd_config
    sed -i 's/^PasswordAuthentication .*/PasswordAuthentication yes/' /etc/ssh/sshd_config
    sed -i 's/^#PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config
    sed -i 's/^PermitRootLogin .*/PermitRootLogin yes/' /etc/ssh/sshd_config

    # Disable SSH key-based authentication
    print_msg "Disabling SSH key-based authentication..."
    sed -i 's/^#PubkeyAuthentication yes/PubkeyAuthentication no/' /etc/ssh/sshd_config
    sed -i 's/^PubkeyAuthentication .*/PubkeyAuthentication no/' /etc/ssh/sshd_config

    # Add a misleading banner to SSH
    print_msg "Creating a misleading SSH banner..."
    echo "Unauthorized access is strictly prohibited. All activities are logged and monitored. Do not try any common passwords FLAG{IAmSneaky}" > /etc/ssh/ssh_banner
    sed -i 's/^#Banner none/Banner \/etc\/ssh\/ssh_banner/' /etc/ssh/sshd_config
    sed -i 's/^Banner .*/Banner \/etc\/ssh\/ssh_banner/' /etc/ssh/sshd_config

    # Hide the SSH version (disable banner version info)
    print_msg "Hiding the SSH version..."
    sed -i 's/^#DebianBanner yes/DebianBanner no/' /etc/ssh/sshd_config
    sed -i 's/^DebianBanner .*/DebianBanner no/' /etc/ssh/sshd_config

    # Check if weakuser exists before adding
    if id "weakuser" &>/dev/null; then
        print_msg "User weakuser already exists."
    else
        adduser --disabled-password --gecos "" weakuser
        echo "weakuser:password123" | chpasswd
        print_msg "Created weakuser with password: password123"
    fi

    # Grant weakuser sudo access for nano and vim only
    echo "weakuser ALL=(ALL) NOPASSWD: /usr/bin/nano, /usr/bin/vim" > /etc/sudoers.d/weakuser_nano_vim

    # Restart SSH service to apply the changes
    print_msg "Restarting SSH service..."
    systemctl restart ssh

    # Remove existing UFW SSH rules
    print_msg "Removing all old UFW SSH rules..."
    ufw delete allow ssh || true

    # Remove UFW rules for port 22
    ufw delete allow 22/tcp || true

    # Allow the new SSH port
    print_msg "Setting up UFW to allow new SSH port ($SSH_RANDOM_PORT)..."
    ufw allow $SSH_RANDOM_PORT/tcp
    ufw reload

    # Configure Knockd for port knocking
    print_msg "Configuring port knocking with knockd..."
    cat > /etc/knockd.conf <<EOL
[options]
    logfile = /var/log/knockd.log

[openSSH]
    sequence    = 7000,8000,9000
    seq_timeout = 5
    command     = /sbin/iptables -A INPUT -s %IP% -p tcp --dport $SSH_RANDOM_PORT -j ACCEPT
    tcpflags    = syn

[closeSSH]
    sequence    = 9000,8000,7000
    seq_timeout = 5
    command     = /sbin/iptables -D INPUT -s %IP% -p tcp --dport $SSH_RANDOM_PORT -j ACCEPT
    tcpflags    = syn
EOL

    # Enable and start the knockd service
    systemctl enable knockd
    systemctl start knockd

    # Create a script to change SSH port every 30 minutes
    print_msg "Setting up script and cron job for SSH port randomization..."

    local SSH_PORT_CHANGE_SCRIPT="/usr/local/bin/change_ssh_port.sh"
    cat > "$SSH_PORT_CHANGE_SCRIPT" <<EOL
#!/bin/bash
NEW_PORT=\$((2000 + RANDOM % 3000))
sed -i "s/^Port [0-9]*/Port \$NEW_PORT/" /etc/ssh/sshd_config
systemctl restart ssh
echo "SSH port changed to: \$NEW_PORT at \$(date)" >> /var/log/ssh_port_changes.log
ufw delete allow $SSH_RANDOM_PORT/tcp
ufw allow \$NEW_PORT/tcp
ufw reload
EOL

    chmod +x "$SSH_PORT_CHANGE_SCRIPT"

    # Set up the cron job to run every 30 minutes
    (crontab -l 2>/dev/null; echo "*/30 * * * * $SSH_PORT_CHANGE_SCRIPT") | crontab -

    print_msg "SSH Vulnerability setup complete on port $SSH_RANDOM_PORT with Port Knocking!"
}

# Prompt to bypass box mode
print_msg "To bypass box mode setup, please enter your admin username and password."
read -p "Username: " ADMIN_USERNAME

# Read password silently
read -s -p "Password: " ADMIN_PASSWORD
echo

# Verify credentials
if id "$ADMIN_USERNAME" &>/dev/null; then
    # Verify password
    if echo "$ADMIN_PASSWORD" | su - "$ADMIN_USERNAME" -c "exit" &>/dev/null; then
        print_msg "Credentials verified. Box mode setup will be bypassed."
        SKIP_BOX=true
    else
        print_msg "Incorrect password. Proceeding with box mode setup."
        SKIP_BOX=false
    fi
else
    print_msg "User $ADMIN_USERNAME does not exist. Proceeding with box mode setup."
    SKIP_BOX=false
fi

# Update package lists and upgrade existing packages
print_msg "Updating and upgrading the system..."
apt-get update && apt-get -y upgrade

# Install necessary packages
print_msg "Installing necessary packages..."
apt-get install -y --no-install-recommends \
    sudo \
    openssl \
    python3 \
    python3-pip \
    python3-venv \
    clamav \
    wget \
    tar \
    bash \
    xinit \
    x11-xserver-utils \
    firefox \
    xdotool \
    unclutter \
    nano \
    gnupg \
    zip \
    unzip \
    ufw \
    nginx \
    apparmor \
    apparmor-utils \
    unattended-upgrades \
    apt-listchanges \
    logwatch \
    vim \
    zenity \
    gcc \
    cron \
    dconf-cli \
    dbus-x11 \
    nfs-kernel-server \
    xbindkeys \
    samba \
    knockd \
    redis-server \
    net-tools \

# Configure UFW Firewall
print_msg "Configuring UFW firewall..."
ufw default deny incoming
ufw default allow outgoing
ufw allow 'Nginx HTTP'

# Navigate to your project directory
print_msg "Navigating to project directory..."
cd ~/web_server

# Remove existing venv if any
print_msg "Removing existing virtual environment (if any)..."
rm -rf venv

# Create a new virtual environment
print_msg "Creating a new virtual environment..."
python3 -m venv venv

# Activate the virtual environment
print_msg "Activating the virtual environment..."
source venv/bin/activate

# Upgrade pip
print_msg "Upgrading pip..."
pip install --upgrade pip

# Install Python dependencies
print_msg "Installing Python dependencies..."
pip install -r requirements.txt

# Manually allow necessary NFS ports in UFW
print_msg "Manually allowing necessary NFS ports in UFW..."
ufw allow 2049/tcp    # NFS service
ufw allow 2049/udp
ufw allow 111/tcp     # Portmapper (rpcbind)
ufw allow 111/udp
ufw allow 20048/tcp   # mountd
ufw allow 20048/udp
ufw allow 20049/tcp   # statd
ufw allow 20049/udp

ufw --force enable

# Create a dedicated user for running the web server
print_msg "Creating dedicated user 'webuser' for the web server..."
if ! id "webuser" &>/dev/null; then
    adduser --system --group --no-create-home webuser
else
    print_msg "User 'webuser' already exists. Skipping creation."
fi

# Copy the web server files from the shared folder to the VM's filesystem
if [ ! -d "$WEB_SERVER_DIR" ]; then
    print_msg "Copying web server files to VM's filesystem..."
    mkdir -p "$WEB_SERVER_DIR"
    cp -r "$SHARED_FOLDER/"* "$WEB_SERVER_DIR"
    chown -R "$ORIGINAL_USER":"$ORIGINAL_USER" "$WEB_SERVER_DIR"
    chmod -R 777 "$WEB_SERVER_DIR"
else
    print_msg "Web server directory already exists. Skipping copy."
fi

# Set up Python virtual environment
if [ ! -d "$WEB_SERVER_DIR/venv" ]; then
    print_msg "Setting up Python virtual environment..."
    python3 -m venv "$WEB_SERVER_DIR/venv"
    source "$WEB_SERVER_DIR/venv/bin/activate"
    print_msg "Installing Python packages from requirements.txt..."
    pip install --upgrade pip
    pip install -r "$WEB_SERVER_DIR/requirements.txt"
    deactivate
    chown -R webuser:webuser "$WEB_SERVER_DIR/venv"
else
    print_msg "Virtual environment already exists. Skipping setup."
fi

# Modify server.py to import config.py if not already modified
if ! grep -q "from config import *" "$WEB_SERVER_DIR/server.py"; then
    print_msg "Modifying server.py to import config.py..."
    sed -i '1s|^|from config import *\n|' "$WEB_SERVER_DIR/server.py"
else
    print_msg "server.py already imports config.py. Skipping modification."
fi

# Create users and set passwords
print_msg "Creating users and setting passwords..."
for USER in "${!USERS_PERMISSIONS[@]}"; do
    if id "$USER" &>/dev/null; then
        echo "User $USER already exists. Skipping creation."
    else
        # Added --allow-bad-names to permit usernames like 'User1', 'User2', etc.
        adduser --disabled-password --gecos "" --allow-bad-names "$USER"
        set_user_password "$USER"
        # Add admin users to sudoers
        if [[ "${USERS_PERMISSIONS[$USER]}" == *"sudo"* ]]; then
            usermod -aG sudo "$USER"
        fi
    fi
done

# Lock root account if it's not already locked
# print_msg "Ensuring root account is locked..."
# passwd -l root || true

# Create directory structure and files for each user
print_msg "Creating directory structures and files for users..."
for USER in "${!USERS_PERMISSIONS[@]}"; do
    USER_HOME="/home/$USER"
    if [ ! -d "${USER_HOME}/Documents" ]; then
        mkdir -p "${USER_HOME}/Documents" "${USER_HOME}/Downloads" "${USER_HOME}/Music" "${USER_HOME}/Pictures" "${USER_HOME}/Videos" "${USER_HOME}/Code"

        # Create some example files with content
        print_msg "Creating example files for $USER..."
        echo "This is a Word document for $USER." > "${USER_HOME}/Documents/document_${USER}.docx"
        echo "This is a PDF file for $USER." > "${USER_HOME}/Documents/file_${USER}.pdf"
        echo "Sample image file for $USER." > "${USER_HOME}/Pictures/image_${USER}.jpg"
        echo "Sample music file for $USER." > "${USER_HOME}/Music/song_${USER}.mp3"
        echo "Sample video file for $USER." > "${USER_HOME}/Videos/video_${USER}.mp4"
        echo "print('Hello, ${USER}!')" > "${USER_HOME}/Code/hello_${USER}.py"

        # Copy the 'ReverseEng' folder to the user's home directory
        if [ -d "$SETUP_FILES_DIR/ReverseEng" ]; then
            print_msg "Copying 'ReverseEng' folder to $USER's home directory..."
            cp -r "$SETUP_FILES_DIR/ReverseEng" "$USER_HOME/"
            chown -R "$USER:$USER" "$USER_HOME/ReverseEng"
        else
            print_msg "'ReverseEng' folder not found in $SETUP_FILES_DIR. Skipping copy."
        fi

        # Create an encrypted file using GPG with chosen encryption method
        print_msg "Creating encrypted file for $USER..."
        echo "Sensitive information for $USER." > "${USER_HOME}/Documents/secret_${USER}.txt"
        
        # Set a predictable passphrase based on seed
        SEED=0
        case "$USER" in
            "User1")
                SEED=1
                ;;
            "User2")
                SEED=2
                ;;
            "User3")
                SEED=3
                ;;
            "admin")
                SEED=4
                ;;
            *)
                SEED=5
                ;;
        esac

        # Generate a simple passphrase using the seed
        PASSPHRASE="seed${SEED}"

        # Encrypt the file with GPG using the predictable passphrase
        gpg --symmetric --cipher-algo "$ENCRYPTION_METHOD" --batch --passphrase "$PASSPHRASE" -o "${USER_HOME}/Documents/secret_${USER}.txt.gpg" "${USER_HOME}/Documents/secret_${USER}.txt"
        shred -u "${USER_HOME}/Documents/secret_${USER}.txt"

        # Set permissions
        chown -R "$USER:$USER" "$USER_HOME"
        chmod -R 700 "$USER_HOME"

        # Horizontal privilege escalation vulnerability implementation (for User2)
        if [ "$USER" == "User2" ]; then
            print_msg "Creating a sensitive file with weak permissions for $USER..."
            echo "FLAG{WeakFilePermission}" > "${USER_HOME}/Documents/sensitive_file.txt"
            chmod 666 "${USER_HOME}/Documents/sensitive_file.txt"  # World-readable and writable permissions
        fi

    else
        echo "Home directories for $USER already exist. Skipping creation."
    fi
done

# Restrict access to certain tools for users
print_msg "Configuring user permissions for specific tools..."
for USER in "${!USERS_PERMISSIONS[@]}"; do
    PERMISSIONS="${USERS_PERMISSIONS[$USER]}"
    for TOOL in "${MANAGED_TOOLS[@]}"; do
        if [[ "$PERMISSIONS" == *"no$TOOL"* ]]; then
            print_msg "Restricting $TOOL access for $USER..."
            TOOL_PATH=$(which $TOOL)
            if [ -n "$TOOL_PATH" ]; then
                setfacl -m u:$USER:0 "$TOOL_PATH"
            fi
        else
            print_msg "Allowing $TOOL access for $USER..."
            TOOL_PATH=$(which $TOOL)
            if [ -n "$TOOL_PATH" ]; then
                setfacl -x u:$USER "$TOOL_PATH" || true
            fi
        fi
    done
done

sudo groupadd webusers || true  # Ignore error if group already exists

# Add all users to the webusers group
for USER in "${!USERS_PERMISSIONS[@]}"; do
    sudo usermod -aG webusers "$USER"
done

# Ensure users have no access to the web server files
print_msg "Restricting user access to web server files..."
chmod -R 777 "$WEB_SERVER_DIR"
chown -R "$ORIGINAL_USER":"webusers" "$WEB_SERVER_DIR"


# Copy the web server files from the shared folder to the VM's filesystem
if [ ! -d "$WEB_SERVER_DIR" ]; then
    print_msg "Copying web server files to VM's filesystem..."
    mkdir -p "$WEB_SERVER_DIR"
    cp -r "$SHARED_FOLDER/"* "$WEB_SERVER_DIR"
    chown -R "$ORIGINAL_USER":"webuser" "$WEB_SERVER_DIR"
    chmod -R 777 "$WEB_SERVER_DIR"
else
    print_msg "Web server directory already exists. Skipping copy."
fi

# Group configuration for shared access
print_msg "Creating shared group and adding users..."
sudo groupadd sharedgroup || true  # Ignore error if group already exists
sudo usermod -aG sharedgroup User1
sudo usermod -aG sharedgroup User2
sudo usermod -aG sharedgroup User3
sudo usermod -aG sharedgroup admin

# Create secret.txt in /usr/local/bin
echo "User2 and User3's keys are in User1's authorized_keys." | sudo tee /usr/local/bin/secret.txt > /dev/null

# SSH configuration for each user
configure_ssh_for_user() {
    USER=$1
    print_msg "Setting up SSH for $USER..."
    sudo mkdir -p /home/$USER/.ssh
    sudo chmod 700 /home/$USER/.ssh
    sudo touch /home/$USER/.ssh/authorized_keys
    sudo chmod 600 /home/$USER/.ssh/authorized_keys 
    sudo chown -R $USER:sharedgroup /home/$USER/.ssh
}

# Generate SSH keys for a user
generate_ssh_key_for_user() {
    USER=$1
    print_msg "Generating SSH keys for $USER..."
    sudo -u $USER ssh-keygen -t rsa -b 2048 -N '' -f /home/$USER/.ssh/id_rsa
}

# Exploit key vulnerability by adding public keys to User1's authorized_keys
exploit_key_vulnerability() {
    print_msg "Exploiting key vulnerability - Adding User2 and User3 public keys to User1's authorized_keys..."
    sudo bash -c 'cat /home/User2/.ssh/id_rsa.pub >> /home/User1/.ssh/authorized_keys'
    sudo bash -c 'cat /home/User3/.ssh/id_rsa.pub >> /home/User1/.ssh/authorized_keys'
}

# Configure SSH for each user
for USER in User1 User2 User3; do
    configure_ssh_for_user $USER
done

# Generate SSH keys for User2 and User3
generate_ssh_key_for_user "User2"
generate_ssh_key_for_user "User3"

# Exploit SSH key vulnerability
exploit_key_vulnerability

# Add NFS Export Misconfiguration Vulnerability
configure_nfs_vulnerability

# Add Sudo Misconfiguration Vulnerability
configure_sudo_vulnerability

# Add Setuid Binary Exploit Vulnerability
configure_setuid_vulnerability

# Add Cronjob Exploit Vulnerability
configure_cronjob_vulnerability

# Add Redis Vulnerability
configure_redis_vulnerability

# Add Samba Vulnerability
configure_samba_vulnerability

# Add SSH Vulnerability
configure_ssh_vulnerability

# Setup box user if not skipping box mode
if [ "$SKIP_BOX" = false ]; then
    if id "box" &>/dev/null; then
        echo "Box user already exists. Skipping creation."
    else
        print_msg "Setting up box user..."
        adduser --disabled-password --gecos "" box
        usermod -aG video box
        # Set the box user's password to be empty
        passwd -d box
    fi

    # Disable screen saver and power management for box user
    print_msg "Disabling screen saver and power management for box user..."

    # Automatically log in box user on tty1
    print_msg "Configuring automatic login for box user on tty1..."
    mkdir -p /etc/systemd/system/getty@tty1.service.d/
    cat > /etc/systemd/system/getty@tty1.service.d/override.conf <<EOF
[Service]
ExecStart=
ExecStart=-/sbin/agetty --autologin box --noclear %I \$TERM
EOF

    # Create .bash_profile for box user to start X session
    print_msg "Creating .bash_profile for box user..."

    cat << 'EOF' > /home/box/.bash_profile
if [ -z "$DISPLAY" ] && [ "$(tty)" = "/dev/tty1" ]; then
    startx
fi
EOF

    # Set ownership
    chown box:box /home/box/.bash_profile

    # Create .xinitrc for box user to launch Firefox
    print_msg "Creating .xinitrc for box user..."

    cat << 'EOF' > /home/box/.xinitrc
#!/bin/bash
xset -dpms      # Disable DPMS (Energy Star) features.
xset s off      # Disable screen saver
xset s noblank  # Don't blank the video device

# Hide the mouse cursor after inactivity
unclutter -idle 0.5 -root &

# Start Firefox in kiosk mode pointing to the web server
firefox --kiosk http://localhost:8080
EOF

    # Set ownership and permissions
    chown box:box /home/box/.xinitrc
    chmod +x /home/box/.xinitrc

fi  # Close the 'if' block for SKIP_BOX

print_msg "Configuring automatic web browser launch for each user..."
for USER in "${!USERS_PERMISSIONS[@]}" "box"; do
    USER_HOME="/home/$USER"
    if [ "$USER" != "root" ]; then
        # Create .bash_profile or .profile if it doesn't exist
        if [ ! -f "$USER_HOME/.bash_profile" ] && [ ! -f "$USER_HOME/.profile" ]; then
            touch "$USER_HOME/.bash_profile"
            print_msg "Created .bash_profile for $USER."
        fi

        # Add command to open the web browser if not already present
        PROFILE_FILE="$USER_HOME/.bash_profile"
        if [ ! -f "$PROFILE_FILE" ]; then
            PROFILE_FILE="$USER_HOME/.profile"
        fi

        if ! grep -q "firefox http://localhost:8080 &" "$PROFILE_FILE"; then
            echo "firefox http://localhost:8080 &" >> "$PROFILE_FILE"
            print_msg "Added Firefox launch command to $PROFILE_FILE for $USER."
        fi

        chown "$USER:$USER" "$PROFILE_FILE"
    fi
done


# Set up the web server to start automatically on boot
if [ ! -f "/usr/local/bin/start_webserver.sh" ]; then
    print_msg "Setting up web server to start on boot..."
    # Create the startup script
    cat > /usr/local/bin/start_webserver.sh <<EOF
#!/bin/bash
# Activate the virtual environment
source "$WEB_SERVER_DIR/venv/bin/activate"
# Navigate to the web server directory
cd "$WEB_SERVER_DIR"
# Run the web server
exec python3 server.py
EOF

    # Make the startup script executable
    chmod +x /usr/local/bin/start_webserver.sh
    chown webuser:webuser /usr/local/bin/start_webserver.sh
else
    print_msg "Startup script already exists. Skipping."
fi

print_msg "Creating or updating systemd service file..."
JWT_SECRET_KEY=$(openssl rand -hex 32)

if [ ! -f /etc/systemd/system/webserver.service ]; then
    cat > /etc/systemd/system/webserver.service <<EOF
[Unit]
Description=Python Web Server
After=network.target

[Service]
Type=simple
User=webuser
WorkingDirectory=$WEB_SERVER_DIR
ExecStart=/usr/local/bin/start_webserver.sh
Restart=on-failure
Environment=JWT_SECRET_KEY=$JWT_SECRET_KEY

[Install]
WantedBy=multi-user.target
EOF

    # Reload systemd and enable the service
    print_msg "Enabling web server service..."
    systemctl daemon-reload
    systemctl enable webserver.service
    systemctl start webserver.service
else
    print_msg "Systemd service file already exists. Reloading and restarting service."
    systemctl daemon-reload
    systemctl restart webserver.service
fi

# Set up backup and recovery plan with rsync
print_msg "Setting up backup directory..."
if [ ! -d "$BACKUP_DIR" ]; then
    mkdir -p "$BACKUP_DIR"
    chown "$ORIGINAL_USER":"$ORIGINAL_USER" "$BACKUP_DIR"
fi

print_msg "Configuring daily backups..."
BACKUP_SCRIPT="/usr/local/bin/backup_webserver.sh"
if [ ! -f "$BACKUP_SCRIPT" ]; then
    cat > "$BACKUP_SCRIPT" <<EOF
#!/bin/bash
rsync -a --exclude='$WEB_SERVER_DIR/venv' $WEB_SERVER_DIR $BACKUP_DIR
EOF
    chmod +x "$BACKUP_SCRIPT"
    (crontab -l 2>/dev/null; echo "0 2 * * * $ORIGINAL_USER $BACKUP_SCRIPT") | crontab -
else
    print_msg "Backup script already exists. Skipping."
fi

print_msg "Setup complete. Please reboot the system to apply all changes."
