#!/bin/bash

# Exit immediately if a command exits with a non-zero status
set -e

# Configuration Section

# Variables (Adjust these variables according to your environment)
ORIGINAL_USER="${SUDO_USER:-$USER}"
WEB_SERVER_DIR="/home/$ORIGINAL_USER/web_server"
SHARED_FOLDER="/media/sf_web_server"
BACKUP_DIR="/backup"
SETUP_FILES_DIR="$(pwd)"  # Assuming the user files are in the current working directory

# Encryption method for secret text (Options: AES256, AES192, AES128, CAST5, BLOWFISH, etc.)
ENCRYPTION_METHOD="AES256"

# User configurations
declare -A USERS_PERMISSIONS=(
    ["User1"]="novim"
    ["User2"]="nonano"
    ["User3"]="novim nonano"
    ["admin"]="sudo"
    ["root"]="sudo"
)

# List of tools to manage permissions for
MANAGED_TOOLS=("vim" "nano" "less" "more")

# Function to print messages
function print_msg() {
    echo -e "\n==== $1 ====\n"
}

# Function to set user passwords automatically
function set_user_password() {
    local USERNAME=$1
    local PASSWORD=""
    
    case "$USERNAME" in
        "User1")
            PASSWORD="useronepasswordone"
            ;;
        "User2")
            PASSWORD="usertwopasswordtwo"
            ;;
        "User3")
            PASSWORD="userthreepasswordthree"
            ;;
        "admin")
            PASSWORD="adminpasswordadmin"
            ;;
        "root")
            # Root password is locked; no action needed
            return
            ;;
        *)
            PASSWORD="defaultpassword"
            ;;
    esac

    # Set the password using chpasswd
    echo "${USERNAME}:${PASSWORD}" | sudo chpasswd
    print_msg "Password set for $USERNAME."
}

# Function to configure NFS Export Misconfiguration (Intentionally Vulnerable)
function configure_nfs_vulnerability() {
    print_msg "Configuring NFS Export Misconfiguration (Vulnerability)..."
    
    # Install NFS server if not already installed
    if ! dpkg -l | grep -qw nfs-kernel-server; then
        print_msg "Installing NFS server..."
        apt-get install -y nfs-kernel-server
    else
        print_msg "NFS server already installed. Skipping installation."
    fi

    # Create the shared directory if it doesn't exist
    if [ ! -d "/shared_dir" ]; then
        print_msg "Creating /shared_dir..."
        mkdir /shared_dir
    else
        print_msg "/shared_dir already exists. Skipping creation."
    fi

    # Set directory permissions to 777 (Open permissions for all users)
    print_msg "Setting permissions for /shared_dir to 777..."
    chmod 777 /shared_dir

    # Assign static ports to NFS services to simplify firewall configuration
    print_msg "Assigning static ports to NFS services..."

    # Backup the original configuration file if not already backed up
    if [ ! -f /etc/default/nfs-kernel-server.backup ]; then
        sudo cp /etc/default/nfs-kernel-server /etc/default/nfs-kernel-server.backup
        print_msg "Backed up /etc/default/nfs-kernel-server to /etc/default/nfs-kernel-server.backup"
    fi

    # Set static ports for mountd and statd
    sudo bash -c 'echo "RPCMOUNTDOPTS=\"--port 20048\"" >> /etc/default/nfs-kernel-server'
    sudo bash -c 'echo "STATDOPTS=\"--port 20049 --outgoing-port 20050\"" >> /etc/default/nfs-kernel-server'

    # Restart NFS services to apply changes
    print_msg "Restarting NFS services to apply static port configurations..."
    systemctl restart nfs-kernel-server
    systemctl restart rpcbind

    # Configure the NFS export with vulnerable settings
    EXPORTS_FILE="/etc/exports"
    EXPORT_ENTRY="/shared_dir *(rw,sync,no_root_squash)"

    if ! grep -Fxq "$EXPORT_ENTRY" "$EXPORTS_FILE"; then
        print_msg "Adding NFS export entry to /etc/exports..."
        echo "$EXPORT_ENTRY" >> "$EXPORTS_FILE"
    else
        print_msg "NFS export entry already exists in /etc/exports. Skipping."
    fi

    # Export the NFS shares
    print_msg "Exporting NFS shares..."
    exportfs -a

    # Start and enable NFS server
    print_msg "Starting and enabling NFS server..."
    systemctl start nfs-kernel-server
    systemctl enable nfs-kernel-server

    print_msg "NFS Export Misconfiguration (Vulnerability) setup complete."
}

# Function to configure Sudo Misconfiguration (Intentionally Vulnerable)
function configure_sudo_vulnerability() {
    print_msg "Configuring Sudo Misconfiguration (Vulnerability)..."
    
    # Ensure sudo package is installed
    if ! dpkg -l | grep -qw sudo; then
        print_msg "Installing sudo..."
        apt-get install -y sudo
    else
        print_msg "sudo already installed. Skipping installation."
    fi

    # Grant specified users permission to run /usr/bin/find without a password
    for USER in "${!USERS_PERMISSIONS[@]}"; do
        if [[ "$USER" != "root" ]]; then
            print_msg "Granting sudo privileges for /usr/bin/find to $USER..."
            echo "$USER ALL=(ALL) NOPASSWD: /usr/bin/find" | sudo tee -a /etc/sudoers.d/$USER-find >/dev/null
            chmod 440 /etc/sudoers.d/$USER-find
        fi
    done

    print_msg "Sudo Misconfiguration (Vulnerability) setup complete."
}

# Function to configure Setuid Binary Exploit (Intentionally Vulnerable)
function configure_setuid_vulnerability() {
    print_msg "Configuring Setuid Binary Exploit (Vulnerability)..."
    
    # Ensure gcc is installed
    if ! dpkg -l | grep -qw gcc; then
        print_msg "Installing gcc..."
        apt-get install -y gcc
    else
        print_msg "gcc already installed. Skipping installation."
    fi

    # Create a temporary directory for compiling the C code
    TEMP_DIR=$(mktemp -d)
    print_msg "Creating temporary directory for Setuid binary compilation at $TEMP_DIR..."

    # Create the C source file
    cat > "$TEMP_DIR/testsetuid.c" <<'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    setuid(0);  // Set the user ID to root
    system("/bin/bash");  // Spawn a shell
    return 0;
}
EOF

    print_msg "Compiling testsetuid.c to /usr/bin/testsetuid..."
    gcc "$TEMP_DIR/testsetuid.c" -o /usr/bin/testsetuid

    # Set ownership to root and set the setuid bit
    print_msg "Setting ownership to root and setting the Setuid bit on /usr/bin/testsetuid..."
    chown root:root /usr/bin/testsetuid
    chmod u+s /usr/bin/testsetuid

    # Clean up the temporary directory
    print_msg "Cleaning up temporary files..."
    rm -rf "$TEMP_DIR"

    print_msg "Setuid Binary Exploit (Vulnerability) setup complete."
}

# Function to configure Cronjob Exploit (Intentionally Vulnerable)
function configure_cronjob_vulnerability() {
    print_msg "Configuring Cronjob Exploit (Vulnerability)..."
    
    # Install cron if not already installed
    if ! dpkg -l | grep -qw cron; then
        print_msg "Installing cron..."
        apt-get install -y cron
    else
        print_msg "cron already installed. Skipping installation."
    fi

    # Create the /var/cronjobs directory if it doesn't exist
    if [ ! -d "/var/cronjobs" ]; then
        print_msg "Creating /var/cronjobs directory..."
        sudo mkdir /var/cronjobs
    else
        print_msg "/var/cronjobs directory already exists. Skipping creation."
    fi

    # Set permissions to 777 (world-writable)
    print_msg "Setting permissions for /var/cronjobs to 777..."
    sudo chmod 777 /var/cronjobs

    # Create the root_script.sh if it doesn't exist
    ROOT_SCRIPT="/var/cronjobs/root_script.sh"
    if [ ! -f "$ROOT_SCRIPT" ]; then
        print_msg "Creating root_script.sh..."
        sudo bash -c 'echo "#!/bin/bash" > /var/cronjobs/root_script.sh'
        sudo bash -c 'echo "touch /root/root_owned_by_user3.txt" >> /var/cronjobs/root_script.sh'
        sudo chmod +x /var/cronjobs/root_script.sh
    else
        print_msg "root_script.sh already exists. Skipping creation."
    fi

    # Add the cronjob to /etc/crontab if not already present
    CRONTAB_ENTRY="*/1 * * * * root /var/cronjobs/root_script.sh"
    if ! grep -Fxq "$CRONTAB_ENTRY" /etc/crontab; then
        print_msg "Adding cronjob entry to /etc/crontab..."
        echo "$CRONTAB_ENTRY" | sudo tee -a /etc/crontab >/dev/null
    else
        print_msg "Cronjob entry already exists in /etc/crontab. Skipping."
    fi

    # Restart cron service to apply changes
    print_msg "Restarting cron service..."
    systemctl restart cron

    print_msg "Cronjob Exploit (Vulnerability) setup complete."
}

# Function to disable GNOME Screen Lock for kiosk user
function disable_gnome_screen_lock() {
    print_msg "Disabling GNOME Screen Lock for kiosk user..."

    # Ensure dconf-cli is installed
    if ! dpkg -l | grep -qw dconf-cli; then
        print_msg "Installing dconf-cli..."
        apt-get install -y dconf-cli
    else
        print_msg "dconf-cli already installed. Skipping installation."
    fi

    # Disable screen lock and idle lock
    sudo -u kiosk dbus-launch gsettings set org.gnome.desktop.screensaver lock-enabled false
    sudo -u kiosk dbus-launch gsettings set org.gnome.desktop.screensaver idle-activation-enabled false
    sudo -u kiosk dbus-launch gsettings set org.gnome.desktop.lockdown disable-lock-screen true

    print_msg "GNOME Screen Lock disabled for kiosk user."
}

# Function to lock kiosk mode by disabling exit methods
lock_kiosk_mode() {
    print_msg "Locking kiosk mode by disabling exit methods..."

    # Ensure the script is run as root
    if [[ "$EUID" -ne 0 ]]; then
        echo "Please run as root."
        exit 1
    fi

    # Disable Ctrl+Alt+Del by masking the systemd target
    echo "Disabling Ctrl+Alt+Del..."
    systemctl mask ctrl-alt-del.target

    # Disable virtual terminal switching (Ctrl+Alt+F1-F12)
    echo "Disabling virtual terminal switching..."
    cat >> /etc/systemd/logind.conf <<EOF
HandleLidSwitch=ignore
HandleLidSwitchDocked=ignore
EOF
    systemctl restart systemd-logind

    # Install necessary packages
    echo "Installing necessary packages..."
    apt-get update
    apt-get install -y xbindkeys xdotool unclutter

    # Disable Alt+F4 using xbindkeys
    echo "Configuring xbindkeys to disable Alt+F4..."
    cat > /etc/xbindkeysrc <<'EOF'
# Disable Alt+F4
"echo 'Alt+F4 pressed' > /dev/null"
    Alt + F4
EOF

    # Start xbindkeys as the kiosk user
    echo "Starting xbindkeys for kiosk user..."
    sudo -u kiosk xbindkeys -f /etc/xbindkeysrc &

    # Create an Xsession script to run Firefox in kiosk mode and apply restrictions
    echo "Creating Xsession script for kiosk user..."
    cat > /home/kiosk/.xsession <<'EOF'
#!/bin/bash
# Disable screen saver and power management
xset s off
xset -dpms
xset s noblank

# Hide the mouse cursor after 1 second of inactivity
unclutter -idle 1 -root &

# Start Firefox in kiosk mode
firefox --kiosk http://localhost:8080 &
EOF

    # Make the Xsession script executable
    chmod +x /home/kiosk/.xsession
    chown kiosk:kiosk /home/kiosk/.xsession

    # Ensure LightDM is configured to use the Xsession script
    echo "Configuring LightDM for kiosk user..."
    cat > /etc/lightdm/lightdm.conf.d/99-kiosk.conf <<EOF
[Seat:*]
autologin-user=kiosk
autologin-user-timeout=0
user-session=kiosk
EOF

    # Restart LightDM to apply changes
    echo "Restarting LightDM..."
    systemctl restart lightdm

    # Prevent users from accessing the system via SSH by disabling SSH for kiosk user
    echo "Disabling SSH access for kiosk user..."
    usermod -L kiosk

    # Finalizing the kiosk lockdown
    print_msg "Lock kiosk mode setup complete."
}

# Prompt to bypass kiosk mode
print_msg "To bypass kiosk mode setup, please enter your admin username and password."
read -p "Username: " ADMIN_USERNAME

# Read password silently
read -s -p "Password: " ADMIN_PASSWORD
echo

# Verify credentials
if id "$ADMIN_USERNAME" &>/dev/null; then
    # Verify password
    if echo "$ADMIN_PASSWORD" | su - "$ADMIN_USERNAME" -c "exit" &>/dev/null; then
        print_msg "Credentials verified. Kiosk mode setup will be bypassed."
        SKIP_KIOSK=true
    else
        print_msg "Incorrect password. Proceeding with kiosk mode setup."
        SKIP_KIOSK=false
    fi
else
    print_msg "User $ADMIN_USERNAME does not exist. Proceeding with kiosk mode setup."
    SKIP_KIOSK=false
fi

# Update package lists and upgrade existing packages
print_msg "Updating and upgrading the system..."
apt-get update && apt-get -y upgrade

# Install necessary packages
print_msg "Installing necessary packages..."
apt-get install -y --no-install-recommends \
    sudo \
    openssl \
    python3 \
    python3-pip \
    python3-venv \
    clamav \
    fail2ban \
    wget \
    tar \
    bash \
    xinit \
    x11-xserver-utils \
    firefox \
    lightdm \
    xdotool \
    unclutter \
    nano \
    gnupg \
    zip \
    unzip \
    ufw \
    nginx \
    apparmor \
    apparmor-utils \
    unattended-upgrades \
    apt-listchanges \
    logwatch \
    vim \
    zenity \
    gcc \
    cron \
    dconf-cli \
    nfs-kernel-server  # Ensure NFS server, gcc, cron, dconf-cli are installed

# Configure UFW Firewall
print_msg "Configuring UFW firewall..."
ufw default deny incoming
ufw default allow outgoing
ufw allow 'Nginx HTTP'

# Manually allow necessary NFS ports in UFW
print_msg "Manually allowing necessary NFS ports in UFW..."
ufw allow 2049/tcp    # NFS service
ufw allow 2049/udp
ufw allow 111/tcp     # Portmapper (rpcbind)
ufw allow 111/udp
ufw allow 20048/tcp   # mountd
ufw allow 20048/udp
ufw allow 20049/tcp   # statd
ufw allow 20049/udp

ufw --force enable

# Copy the web server files from the shared folder to the VM's filesystem
if [ ! -d "$WEB_SERVER_DIR" ]; then
    print_msg "Copying web server files to VM's filesystem..."
    mkdir -p "$WEB_SERVER_DIR"
    cp -r "$SHARED_FOLDER/"* "$WEB_SERVER_DIR"
    chown -R "$ORIGINAL_USER":"$ORIGINAL_USER" "$WEB_SERVER_DIR"
    chmod -R 750 "$WEB_SERVER_DIR"
else
    print_msg "Web server directory already exists. Skipping copy."
fi

# Set up Python virtual environment
if [ ! -d "$WEB_SERVER_DIR/venv" ]; then
    print_msg "Setting up Python virtual environment..."
    python3 -m venv "$WEB_SERVER_DIR/venv"
    source "$WEB_SERVER_DIR/venv/bin/activate"
    print_msg "Installing Python packages from requirements.txt..."
    pip install --upgrade pip
    pip install -r "$WEB_SERVER_DIR/requirements.txt"
    deactivate
else
    print_msg "Virtual environment already exists. Skipping setup."
fi

# Modify server.py to import config.py if not already modified
if ! grep -q "from config import *" "$WEB_SERVER_DIR/server.py"; then
    print_msg "Modifying server.py to import config.py..."
    sed -i '1s|^|from config import *\n|' "$WEB_SERVER_DIR/server.py"
else
    print_msg "server.py already imports config.py. Skipping modification."
fi

# Create users and set passwords
print_msg "Creating users and setting passwords..."
for USER in "${!USERS_PERMISSIONS[@]}"; do
    if id "$USER" &>/dev/null; then
        echo "User $USER already exists. Skipping creation."
    else
        # Added --allow-bad-names to permit usernames like 'User1', 'User2', etc.
        adduser --disabled-password --gecos "" --allow-bad-names "$USER"
        set_user_password "$USER"
        # Add admin users to sudoers
        if [[ "${USERS_PERMISSIONS[$USER]}" == *"sudo"* ]]; then
            usermod -aG sudo "$USER"
        fi
    fi
done

# Lock root account if it's not already locked
print_msg "Ensuring root account is locked..."
passwd -l root || true

# Create directory structure and files for each user
print_msg "Creating directory structures and files for users..."
for USER in "${!USERS_PERMISSIONS[@]}"; do
    USER_HOME="/home/$USER"
    if [ ! -d "${USER_HOME}/Documents" ]; then
        mkdir -p "${USER_HOME}/Documents" "${USER_HOME}/Downloads" "${USER_HOME}/Music" "${USER_HOME}/Pictures" "${USER_HOME}/Videos" "${USER_HOME}/Code"

        # Create some example files with content
        print_msg "Creating example files for $USER..."
        echo "This is a Word document for $USER." > "${USER_HOME}/Documents/document_${USER}.docx"
        echo "This is a PDF file for $USER." > "${USER_HOME}/Documents/file_${USER}.pdf"
        echo "Sample image file for $USER." > "${USER_HOME}/Pictures/image_${USER}.jpg"
        echo "Sample music file for $USER." > "${USER_HOME}/Music/song_${USER}.mp3"
        echo "Sample video file for $USER." > "${USER_HOME}/Videos/video_${USER}.mp4"
        echo "print('Hello, ${USER}!')" > "${USER_HOME}/Code/hello_${USER}.py"

        # Copy files from the setup directory
        if [ -d "$SETUP_FILES_DIR/$USER" ]; then
            print_msg "Copying custom files to $USER's home directory..."
            cp -r "$SETUP_FILES_DIR/$USER/." "$USER_HOME/"
        fi

        # Create an encrypted file using GPG with chosen encryption method
        print_msg "Creating encrypted file for $USER..."
        echo "Sensitive information for $USER." > "${USER_HOME}/Documents/secret_${USER}.txt"
        
        # Set a predictable passphrase based on seed
        SEED=0
        case "$USER" in
            "User1")
                SEED=1
                ;;
            "User2")
                SEED=2
                ;;
            "User3")
                SEED=3
                ;;
            "admin")
                SEED=4
                ;;
            *)
                SEED=5
                ;;
        esac

        # Generate a simple passphrase using the seed
        PASSPHRASE="seed${SEED}"

        # Encrypt the file with GPG using the predictable passphrase
        gpg --symmetric --cipher-algo "$ENCRYPTION_METHOD" --batch --passphrase "$PASSPHRASE" -o "${USER_HOME}/Documents/secret_${USER}.txt.gpg" "${USER_HOME}/Documents/secret_${USER}.txt"
        shred -u "${USER_HOME}/Documents/secret_${USER}.txt"

        # Set permissions
        chown -R "$USER:$USER" "$USER_HOME"
        chmod -R 700 "$USER_HOME"

        # Horizontal privilege escalation vulnerability implementation (for User2)
        if [ "$USER" == "User2" ]; then
            print_msg "Creating a sensitive file with weak permissions for $USER..."
            echo "FLAG{WeakFilePermission}" > "${USER_HOME}/Documents/sensitive_file.txt"
            chmod 666 "${USER_HOME}/Documents/sensitive_file.txt"  # World-readable and writable permissions
        fi

    else
        echo "Home directories for $USER already exist. Skipping creation."
    fi
done

# Restrict access to certain tools for users
print_msg "Configuring user permissions for specific tools..."
for USER in "${!USERS_PERMISSIONS[@]}"; do
    PERMISSIONS="${USERS_PERMISSIONS[$USER]}"
    for TOOL in "${MANAGED_TOOLS[@]}"; do
        if [[ "$PERMISSIONS" == *"no$TOOL"* ]]; then
            print_msg "Restricting $TOOL access for $USER..."
            TOOL_PATH=$(which $TOOL)
            if [ -n "$TOOL_PATH" ]; then
                setfacl -m u:$USER:0 "$TOOL_PATH"
            fi
        else
            print_msg "Allowing $TOOL access for $USER..."
            TOOL_PATH=$(which $TOOL)
            if [ -n "$TOOL_PATH" ]; then
                setfacl -x u:$USER "$TOOL_PATH" || true
            fi
        fi
    done
done

# Ensure users have no access to the web server files
print_msg "Restricting user access to web server files..."
chmod -R 750 "$WEB_SERVER_DIR"
chown -R "$ORIGINAL_USER":"$ORIGINAL_USER" "$WEB_SERVER_DIR"

# Group configuration for shared access
print_msg "Creating shared group and adding users..."
sudo groupadd sharedgroup || true  # Ignore error if group already exists
sudo usermod -aG sharedgroup User1
sudo usermod -aG sharedgroup User2
sudo usermod -aG sharedgroup User3
sudo usermod -aG sharedgroup admin

# Create secret.txt in /usr/local/bin
echo "User2 and User3's keys are in User1's authorized_keys." | sudo tee /usr/local/bin/secret.txt > /dev/null

# SSH configuration for each user
configure_ssh_for_user() {
    USER=$1
    print_msg "Setting up SSH for $USER..."
    sudo mkdir -p /home/$USER/.ssh
    sudo chmod 700 /home/$USER/.ssh
    sudo touch /home/$USER/.ssh/authorized_keys
    sudo chmod 600 /home/$USER/.ssh/authorized_keys 
    sudo chown -R $USER:sharedgroup /home/$USER/.ssh
}

# Generate SSH keys for a user
generate_ssh_key_for_user() {
    USER=$1
    print_msg "Generating SSH keys for $USER..."
    sudo -u $USER ssh-keygen -t rsa -b 2048 -N '' -f /home/$USER/.ssh/id_rsa
}

# Exploit key vulnerability by adding public keys to User1's authorized_keys
exploit_key_vulnerability() {
    print_msg "Exploiting key vulnerability - Adding User2 and User3 public keys to User1's authorized_keys..."
    sudo bash -c 'cat /home/User2/.ssh/id_rsa.pub >> /home/User1/.ssh/authorized_keys'
    sudo bash -c 'cat /home/User3/.ssh/id_rsa.pub >> /home/User1/.ssh/authorized_keys'
}

# Configure SSH for each user
for USER in User1 User2 User3; do
    configure_ssh_for_user $USER
done

# Generate SSH keys for User2 and User3
generate_ssh_key_for_user "User2"
generate_ssh_key_for_user "User3"

# Exploit SSH key vulnerability
exploit_key_vulnerability

# Add NFS Export Misconfiguration Vulnerability
configure_nfs_vulnerability

# Add Sudo Misconfiguration Vulnerability
configure_sudo_vulnerability

# Add Setuid Binary Exploit Vulnerability
configure_setuid_vulnerability

# Add Cronjob Exploit Vulnerability
configure_cronjob_vulnerability


# Setup kiosk user if not skipping kiosk mode
if [ "$SKIP_KIOSK" = false ]; then
    if id "kiosk" &>/dev/null; then
        echo "Kiosk user already exists. Skipping creation."
    else
        print_msg "Setting up kiosk user..."
        adduser --disabled-password --gecos "" kiosk
        usermod -aG video kiosk
        # Set the kiosk user's password to be empty
        passwd -d kiosk
    fi

    # Note: Removed automatic login configuration for kiosk user

    # Create an Xsession script for kiosk mode
    print_msg "Setting up Xsession script for kiosk user with debug statements..."
    cat > /home/kiosk/.xsession <<'EOF'
#!/bin/bash
echo "Starting .xsession script for kiosk user..." >> /home/kiosk/xsession-debug.log

xset -dpms      # Disable DPMS (Energy Star) features.
xset s off      # Disable screen saver
xset s noblank  # Don't blank the video device

echo "Disabled screen saver and power management settings." >> /home/kiosk/xsession-debug.log

# Disable GNOME Screen Lock
echo "Attempting to disable GNOME Screen Lock..." >> /home/kiosk/xsession-debug.log
dbus-launch gsettings set org.gnome.desktop.screensaver lock-enabled false
dbus-launch gsettings set org.gnome.desktop.screensaver idle-activation-enabled false
dbus-launch gsettings set org.gnome.desktop.lockdown disable-lock-screen true
echo "GNOME Screen Lock settings applied." >> /home/kiosk/xsession-debug.log

# Function to prompt for credentials and bypass kiosk mode
function prompt_for_credentials() {
    while true; do
        USERNAME=$(zenity --entry --title="Bypass Kiosk Mode" --text="Enter username to bypass kiosk mode:")
        if [ -z "$USERNAME" ]; then
            # User cancelled
            echo "User cancelled the username prompt." >> /home/kiosk/xsession-debug.log
            break
        fi
        PASSWORD=$(zenity --password --title="Bypass Kiosk Mode")
        if [ -z "$PASSWORD" ]; then
            # User cancelled
            echo "User cancelled the password prompt." >> /home/kiosk/xsession-debug.log
            break
        fi
        if id "$USERNAME" &>/dev/null; then
            # Verify password
            if echo "$PASSWORD" | su - "$USERNAME" -c "exit" &>/dev/null; then
                # Correct credentials, exit kiosk mode
                echo "Credentials verified for user $USERNAME. Exiting kiosk mode." >> /home/kiosk/xsession-debug.log
                # Kill X session
                pkill -KILL -u kiosk
                exit
            else
                zenity --error --text="Incorrect password. Please try again."
                echo "Incorrect password entered for user $USERNAME." >> /home/kiosk/xsession-debug.log
            fi
        else
            zenity --error --text="User does not exist. Please try again."
            echo "User $USERNAME does not exist." >> /home/kiosk/xsession-debug.log
        fi
    done
}

# Prompt for credentials to bypass kiosk mode
echo "Prompting for credentials to bypass kiosk mode..." >> /home/kiosk/xsession-debug.log
prompt_for_credentials
echo "Credential prompt completed." >> /home/kiosk/xsession-debug.log

# Hide the mouse cursor after inactivity
unclutter -idle 0.5 -root &
echo "Started unclutter to hide mouse cursor." >> /home/kiosk/xsession-debug.log

# Start Firefox in kiosk mode pointing to the web server
echo "Starting Firefox in kiosk mode..." >> /home/kiosk/xsession-debug.log
firefox --kiosk http://localhost:8080
echo "Firefox has exited." >> /home/kiosk/xsession-debug.log
EOF
    # Make the Xsession script executable
    chmod +x /home/kiosk/.xsession

    # Set ownership
    chown kiosk:kiosk /home/kiosk/.xsession

    # Disable screen lock for kiosk user with debug statements
    disable_gnome_screen_lock

    # Lock down the kiosk user account without changing the shell
    print_msg "Locking down kiosk user account..."
    chmod 700 /home/kiosk


    # Integrate the lock_kiosk_mode function
    # lock_kiosk_mode

else
    print_msg "Skipping kiosk mode setup as per user request."
fi

# Ensure ownership and permissions of .xsession
chown kiosk:kiosk /home/kiosk/.xsession
chmod +x /home/kiosk/.xsession

# Set up the web server to start automatically on boot
if [ ! -f "/usr/local/bin/start_webserver.sh" ]; then
    print_msg "Setting up web server to start on boot..."
    # Create the startup script
    cat > /usr/local/bin/start_webserver.sh <<EOF
#!/bin/bash
# Activate the virtual environment
source "$WEB_SERVER_DIR/venv/bin/activate"
# Navigate to the web server directory
cd "$WEB_SERVER_DIR"
# Run the web server
exec python3 server.py
EOF

    # Make the startup script executable
    chmod +x /usr/local/bin/start_webserver.sh
else
    print_msg "Startup script already exists. Skipping."
fi

# Create the systemd service file
print_msg "Creating or updating systemd service file..."
JWT_SECRET_KEY=$(openssl rand -hex 32)
cat > /etc/systemd/system/webserver.service <<EOF
[Unit]
Description=Python Web Server
After=network.target

[Service]
Type=simple
User=$ORIGINAL_USER
WorkingDirectory=$WEB_SERVER_DIR
ExecStart=/usr/local/bin/start_webserver.sh
Restart=on-failure
Environment=JWT_SECRET_KEY=$JWT_SECRET_KEY

[Install]
WantedBy=multi-user.target
EOF

    # Reload systemd and enable the service
    print_msg "Enabling web server service..."
    systemctl daemon-reload
    systemctl enable webserver.service
    systemctl start webserver.service
else
    print_msg "Systemd service file already exists. Reloading and restarting service."
    systemctl daemon-reload
    systemctl restart webserver.service
fi

# Configure Nginx as a reverse proxy without HTTPS
print_msg "Configuring Nginx as a reverse proxy..."
# Remove default site
rm -f /etc/nginx/sites-enabled/default

# Create Nginx configuration
cat > /etc/nginx/sites-available/webserver <<EOF
server {
    listen 80;
    server_name localhost;
    root /var/www/html;

    location / {
        proxy_pass http://localhost:8080;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
    }
}
EOF

ln -sf /etc/nginx/sites-available/webserver /etc/nginx/sites-enabled/webserver
nginx -t
systemctl restart nginx

# Secure Nginx configuration
print_msg "Securing Nginx configuration..."
cat > /etc/nginx/nginx.conf <<'EOF'
user www-data;
worker_processes auto;
pid /run/nginx.pid;
events {
    worker_connections 1024;
}
http {
    server_tokens off;
    include /etc/nginx/mime.types;
    default_type application/octet-stream;
    add_header X-Frame-Options SAMEORIGIN;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
    include /etc/nginx/conf.d/*.conf;
    include /etc/nginx/sites-enabled/*;
}
EOF
nginx -t
systemctl restart nginx

# Configure Fail2Ban
print_msg "Setting up Fail2Ban..."
systemctl enable fail2ban
systemctl start fail2ban

# Create Fail2Ban configuration for Nginx
cat > /etc/fail2ban/jail.d/nginx-http-auth.conf <<EOF
[nginx-http-auth]
enabled = true
filter = nginx-http-auth
action = iptables[name=HTTP, port=http, protocol=tcp]
logpath = /var/log/nginx/error.log
EOF

systemctl restart fail2ban

# Configure automatic security updates
print_msg "Setting up automatic security updates..."
cat > /etc/apt/apt.conf.d/20auto-upgrades <<EOF
APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Unattended-Upgrade "1";
EOF

# Enable AppArmor
print_msg "Enabling AppArmor..."
systemctl enable apparmor
systemctl start apparmor

# Log monitoring with logwatch
print_msg "Configuring logwatch for log monitoring..."
LOGWATCH_CRON="/etc/cron.daily/00logwatch"
if [ ! -f "$LOGWATCH_CRON" ]; then
    cat > "$LOGWATCH_CRON" <<EOF
#!/bin/bash
/usr/sbin/logwatch --output mail --mailto root --detail high
EOF
    chmod +x "$LOGWATCH_CRON"
else
    print_msg "Logwatch cron job already exists. Skipping."
fi

# Set up backup and recovery plan with rsync
print_msg "Setting up backup directory..."
if [ ! -d "$BACKUP_DIR" ]; then
    mkdir -p "$BACKUP_DIR"
    chown "$ORIGINAL_USER":"$ORIGINAL_USER" "$BACKUP_DIR"
fi

print_msg "Configuring daily backups..."
BACKUP_SCRIPT="/usr/local/bin/backup_webserver.sh"
if [ ! -f "$BACKUP_SCRIPT" ]; then
    cat > "$BACKUP_SCRIPT" <<EOF
#!/bin/bash
rsync -a --exclude='$WEB_SERVER_DIR/venv' $WEB_SERVER_DIR $BACKUP_DIR
EOF
    chmod +x "$BACKUP_SCRIPT"
    (crontab -l 2>/dev/null; echo "0 2 * * * $ORIGINAL_USER $BACKUP_SCRIPT") | crontab -
else
    print_msg "Backup script already exists. Skipping."
fi

print_msg "Setup complete. Please reboot the system to apply all changes."
