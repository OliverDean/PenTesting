#!/bin/bash

# Exit immediately if a command exits with a non-zero status
set -e

# Configuration Section

# Variables (Adjust these variables according to your environment)
ORIGINAL_USER="${SUDO_USER:-$USER}"
WEB_SERVER_DIR="/home/$ORIGINAL_USER/web_server"
SHARED_FOLDER="/media/sf_web_server"
BACKUP_DIR="/backup"
SETUP_FILES_DIR="$(pwd)"  # Assuming the user files are in the current working directory

# Encryption method for secret text (Options: AES256, AES192, AES128, CAST5, BLOWFISH, etc.)
ENCRYPTION_METHOD="AES256"

# User configurations
declare -A USERS_PERMISSIONS=(
    ["user1"]="novim"
    ["user2"]="nonano"
    ["user3"]="novim nonano"
    ["admin"]="sudo"
    ["root"]="sudo"
)

# List of tools to manage permissions for
MANAGED_TOOLS=("vim" "nano" "less" "more")

# Function to print messages
function print_msg() {
    echo -e "\n==== $1 ====\n"
}

# Function to set user passwords securely
function set_user_password() {
    local USERNAME=$1
    print_msg "Please set a password for user $USERNAME:"
    passwd "$USERNAME"
}

# Prompt to bypass kiosk mode
print_msg "To bypass kiosk mode setup, please enter your admin username and password."
read -p "Username: " ADMIN_USERNAME

# Read password silently
read -s -p "Password: " ADMIN_PASSWORD
echo

# Verify credentials
if id "$ADMIN_USERNAME" &>/dev/null; then
    # Verify password
    if echo "$ADMIN_PASSWORD" | su - "$ADMIN_USERNAME" -c "exit" &>/dev/null; then
        print_msg "Credentials verified. Kiosk mode setup will be bypassed."
        SKIP_KIOSK=true
    else
        print_msg "Incorrect password. Proceeding with kiosk mode setup."
        SKIP_KIOSK=false
    fi
else
    print_msg "User $ADMIN_USERNAME does not exist. Proceeding with kiosk mode setup."
    SKIP_KIOSK=false
fi

# Update package lists and upgrade existing packages
print_msg "Updating and upgrading the system..."
apt-get update && apt-get -y upgrade

# Install necessary packages
print_msg "Installing necessary packages..."
apt-get install -y --no-install-recommends \
    sudo \
    openssl \
    python3 \
    python3-pip \
    python3-venv \
    clamav \
    fail2ban \
    wget \
    tar \
    bash \
    xinit \
    x11-xserver-utils \
    firefox \
    lightdm \
    xdotool \
    unclutter \
    nano \
    gnupg \
    zip \
    unzip \
    ufw \
    nginx \
    apparmor \
    apparmor-utils \
    unattended-upgrades \
    apt-listchanges \
    logwatch \
    vim \
    zenity

# Configure UFW Firewall
print_msg "Configuring UFW firewall..."
ufw default deny incoming
ufw default allow outgoing
ufw allow 'Nginx HTTP'
ufw --force enable

# Copy the web server files from the shared folder to the VM's filesystem
if [ ! -d "$WEB_SERVER_DIR" ]; then
    print_msg "Copying web server files to VM's filesystem..."
    mkdir -p "$WEB_SERVER_DIR"
    cp -r "$SHARED_FOLDER/"* "$WEB_SERVER_DIR"
    chown -R "$ORIGINAL_USER":"$ORIGINAL_USER" "$WEB_SERVER_DIR"
    chmod -R 750 "$WEB_SERVER_DIR"
else
    print_msg "Web server directory already exists. Skipping copy."
fi

# Set up Python virtual environment
if [ ! -d "$WEB_SERVER_DIR/venv" ]; then
    print_msg "Setting up Python virtual environment..."
    python3 -m venv "$WEB_SERVER_DIR/venv"
    source "$WEB_SERVER_DIR/venv/bin/activate"
    print_msg "Installing Python packages from requirements.txt..."
    pip install --upgrade pip
    pip install -r "$WEB_SERVER_DIR/requirements.txt"
    deactivate
else
    print_msg "Virtual environment already exists. Skipping setup."
fi

# Create a config.py file for global variables if it doesn't exist
if [ ! -f "$WEB_SERVER_DIR/config.py" ]; then
    print_msg "Creating config.py..."
    cat > "$WEB_SERVER_DIR/config.py" <<EOL
import os
from datetime import timedelta

# Secret key for security (use environment variable in production)
SECRET_KEY = os.getenv('JWT_SECRET_KEY', os.urandom(24).hex())
PASSWORD_MIN_LENGTH = 12

# Logging configuration
LOG_LEVEL = 'INFO'
LOG_FORMAT = '%(asctime)s - %(levelname)s - %(message)s'

# Rate limiter settings
RATE_LIMIT_WINDOW = 60  # in seconds
RATE_LIMIT_MAX_ATTEMPTS = 100

# CORS setup options
CORS_OPTIONS = {
    "*": {
        "allow_credentials": True,
        "expose_headers": "*",
        "allow_headers": "*",
    }
}

# Allowed file extensions and max file size for uploads
ALLOWED_EXTENSIONS = {'.jpg', '.jpeg', '.png', '.pdf', '.txt', '.docx', '.xlsx'}
MAX_FILE_SIZE = 5 * 1024 * 1024  # 5 MB

# Pagination limit
MAX_LIMIT = 100

# JWT settings
JWT_ALGORITHM = 'HS256'
JWT_EXP_DELTA = timedelta(hours=1)
EOL
else
    print_msg "config.py already exists. Skipping creation."
fi

# Modify server.py to import config.py if not already modified
if ! grep -q "from config import *" "$WEB_SERVER_DIR/server.py"; then
    print_msg "Modifying server.py to import config.py..."
    sed -i '1s|^|from config import *\n|' "$WEB_SERVER_DIR/server.py"
else
    print_msg "server.py already imports config.py. Skipping modification."
fi

# Create users and set passwords
print_msg "Creating users and setting passwords..."
for USER in "${!USERS_PERMISSIONS[@]}"; do
    if id "$USER" &>/dev/null; then
        echo "User $USER already exists. Skipping creation."
    else
        adduser --disabled-password --gecos "" "$USER"
        set_user_password "$USER"
        # Add admin users to sudoers
        if [[ "${USERS_PERMISSIONS[$USER]}" == *"sudo"* ]]; then
            usermod -aG sudo "$USER"
        fi
    fi
done

# Lock root account if it's not already locked
print_msg "Ensuring root account is locked..."
passwd -l root || true

# Create directory structure and files for each user
print_msg "Creating directory structures and files for users..."
for USER in "${!USERS_PERMISSIONS[@]}"; do
    USER_HOME="/home/$USER"
    if [ ! -d "${USER_HOME}/Documents" ]; then
        mkdir -p "${USER_HOME}/Documents" "${USER_HOME}/Downloads" "${USER_HOME}/Music" "${USER_HOME}/Pictures" "${USER_HOME}/Videos" "${USER_HOME}/Code"

        # Create some example files with content
        print_msg "Creating example files for $USER..."
        echo "This is a Word document for $USER." > "${USER_HOME}/Documents/document_${USER}.docx"
        echo "This is a PDF file for $USER." > "${USER_HOME}/Documents/file_${USER}.pdf"
        echo "Sample image file for $USER." > "${USER_HOME}/Pictures/image_${USER}.jpg"
        echo "Sample music file for $USER." > "${USER_HOME}/Music/song_${USER}.mp3"
        echo "Sample video file for $USER." > "${USER_HOME}/Videos/video_${USER}.mp4"
        echo "print('Hello, ${USER}!')" > "${USER_HOME}/Code/hello_${USER}.py"

        # Copy files from the setup directory
        if [ -d "$SETUP_FILES_DIR/$USER" ]; then
            print_msg "Copying custom files to $USER's home directory..."
            cp -r "$SETUP_FILES_DIR/$USER/." "$USER_HOME/"
        fi

        # Create an encrypted file using GPG with chosen encryption method
        print_msg "Creating encrypted file for $USER..."
        echo "Sensitive information for $USER." > "${USER_HOME}/Documents/secret_${USER}.txt"
        print_msg "Please enter a passphrase for encrypting $USER's secret file:"
        read -s PASSPHRASE
        echo
        gpg --symmetric --cipher-algo "$ENCRYPTION_METHOD" --batch --passphrase "$PASSPHRASE" -o "${USER_HOME}/Documents/secret_${USER}.txt.gpg" "${USER_HOME}/Documents/secret_${USER}.txt"
        shred -u "${USER_HOME}/Documents/secret_${USER}.txt"

        # Set permissions
        chown -R "$USER:$USER" "$USER_HOME"
        chmod -R 700 "$USER_HOME"
    else
        echo "Home directories for $USER already exist. Skipping creation."
    fi
done

# Restrict access to certain tools for users
print_msg "Configuring user permissions for specific tools..."
for USER in "${!USERS_PERMISSIONS[@]}"; do
    PERMISSIONS="${USERS_PERMISSIONS[$USER]}"
    for TOOL in "${MANAGED_TOOLS[@]}"; do
        if [[ "$PERMISSIONS" == *"no$TOOL"* ]]; then
            print_msg "Restricting $TOOL access for $USER..."
            TOOL_PATH=$(which $TOOL)
            if [ -n "$TOOL_PATH" ]; then
                setfacl -m u:$USER:0 "$TOOL_PATH"
            fi
        else
            print_msg "Allowing $TOOL access for $USER..."
            TOOL_PATH=$(which $TOOL)
            if [ -n "$TOOL_PATH" ]; then
                setfacl -x u:$USER "$TOOL_PATH" || true
            fi
        fi
    done
done

# Ensure users have no access to the web server files
print_msg "Restricting user access to web server files..."
chmod -R 750 "$WEB_SERVER_DIR"
chown -R "$ORIGINAL_USER":"$ORIGINAL_USER" "$WEB_SERVER_DIR"

# Setup kiosk user if not skipping kiosk mode
if [ "$SKIP_KIOSK" = false ]; then
    if id "kiosk" &>/dev/null; then
        echo "Kiosk user already exists. Skipping creation."
    else
        print_msg "Setting up kiosk user..."
        adduser --disabled-password --gecos "" kiosk
        usermod -aG video kiosk
    fi

    # Configure automatic login for kiosk user
    print_msg "Configuring automatic login for kiosk user..."
    LIGHTDM_CONF="/etc/lightdm/lightdm.conf"
    if [ ! -f "$LIGHTDM_CONF" ]; then
        cat > "$LIGHTDM_CONF" <<EOF
[Seat:*]
autologin-user=kiosk
autologin-user-timeout=0
user-session=ubuntu
EOF
    else
        print_msg "LightDM configuration already exists. Updating autologin settings."
        sed -i '/^autologin-user=/d' "$LIGHTDM_CONF"
        sed -i '/^autologin-user-timeout=/d' "$LIGHTDM_CONF"
        echo "autologin-user=kiosk" >> "$LIGHTDM_CONF"
        echo "autologin-user-timeout=0" >> "$LIGHTDM_CONF"
    fi

    # Create an Xsession script for kiosk mode
    if [ ! -f "/home/kiosk/.xsession" ]; then
        print_msg "Creating Xsession script for kiosk mode..."
        cat > /home/kiosk/.xsession <<'EOF'
#!/bin/bash
xset -dpms      # Disable DPMS (Energy Star) features.
xset s off      # Disable screen saver
xset s noblank  # Don't blank the video device

# Function to prompt for credentials and bypass kiosk mode
function prompt_for_credentials() {
    while true; do
        USERNAME=$(zenity --entry --title="Bypass Kiosk Mode" --text="Enter username to bypass kiosk mode:")
        if [ -z "$USERNAME" ]; then
            # User cancelled
            break
        fi
        PASSWORD=$(zenity --password --title="Bypass Kiosk Mode")
        if [ -z "$PASSWORD" ]; then
            # User cancelled
            break
        fi
        if id "$USERNAME" &>/dev/null; then
            # Verify password
            if echo "$PASSWORD" | su - "$USERNAME" -c "exit" &>/dev/null; then
                # Correct credentials, exit kiosk mode
                echo "Credentials verified. Exiting kiosk mode."
                # Kill X session
                pkill -KILL -u kiosk
                exit
            else
                zenity --error --text="Incorrect password. Please try again."
            fi
        else
            zenity --error --text="User does not exist. Please try again."
        fi
    done
}

# Prompt for credentials to bypass kiosk mode
prompt_for_credentials

# Hide the mouse cursor after inactivity
unclutter -idle 0.5 -root &

# Start Firefox in kiosk mode pointing to the web server
firefox --kiosk http://localhost
EOF
        # Make the Xsession script executable
        chmod +x /home/kiosk/.xsession

        # Set ownership
        chown kiosk:kiosk /home/kiosk/.xsession

        # Lock down the kiosk user account
        print_msg "Locking down kiosk user account..."
        usermod -s /usr/sbin/nologin kiosk
        chmod 700 /home/kiosk
    else
        print_msg ".xsession script for kiosk user already exists. Skipping."
    fi
else
    print_msg "Skipping kiosk mode setup as per user request."
fi

# Set up the web server to start automatically on boot
if [ ! -f "/usr/local/bin/start_webserver.sh" ]; then
    print_msg "Setting up web server to start on boot..."
    # Create the startup script
    cat > /usr/local/bin/start_webserver.sh <<EOF
#!/bin/bash
# Activate the virtual environment
source "$WEB_SERVER_DIR/venv/bin/activate"
# Navigate to the web server directory
cd "$WEB_SERVER_DIR"
# Run the web server
exec python3 server.py
EOF

    # Make the startup script executable
    chmod +x /usr/local/bin/start_webserver.sh
else
    print_msg "Startup script already exists. Skipping."
fi

# Create the systemd service file
if [ ! -f "/etc/systemd/system/webserver.service" ]; then
    print_msg "Creating systemd service file..."
    JWT_SECRET_KEY=$(openssl rand -hex 32)
    cat > /etc/systemd/system/webserver.service <<EOF
[Unit]
Description=Python Web Server
After=network.target

[Service]
Type=simple
User=$ORIGINAL_USER
WorkingDirectory=$WEB_SERVER_DIR
ExecStart=/usr/local/bin/start_webserver.sh
Restart=on-failure
Environment=JWT_SECRET_KEY=$JWT_SECRET_KEY

[Install]
WantedBy=multi-user.target
EOF

    # Reload systemd and enable the service
    print_msg "Enabling web server service..."
    systemctl daemon-reload
    systemctl enable webserver.service
    systemctl start webserver.service
else
    print_msg "Systemd service file already exists. Reloading and restarting service."
    systemctl daemon-reload
    systemctl restart webserver.service
fi

# Configure Nginx as a reverse proxy without HTTPS
print_msg "Configuring Nginx as a reverse proxy..."
# Remove default site
rm -f /etc/nginx/sites-enabled/default

# Create Nginx configuration
cat > /etc/nginx/sites-available/webserver <<EOF
server {
    listen 80;
    server_name localhost;
    root /var/www/html;

    location / {
        proxy_pass http://localhost:8080;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
    }
}
EOF

ln -sf /etc/nginx/sites-available/webserver /etc/nginx/sites-enabled/webserver
nginx -t
systemctl restart nginx

# Secure Nginx configuration
print_msg "Securing Nginx configuration..."
cat > /etc/nginx/nginx.conf <<'EOF'
user www-data;
worker_processes auto;
pid /run/nginx.pid;
events {
    worker_connections 1024;
}
http {
    server_tokens off;
    include /etc/nginx/mime.types;
    default_type application/octet-stream;
    add_header X-Frame-Options SAMEORIGIN;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
    include /etc/nginx/conf.d/*.conf;
    include /etc/nginx/sites-enabled/*;
}
EOF
nginx -t
systemctl restart nginx

# Configure Fail2Ban
print_msg "Setting up Fail2Ban..."
systemctl enable fail2ban
systemctl start fail2ban

# Create Fail2Ban configuration for Nginx
cat > /etc/fail2ban/jail.d/nginx-http-auth.conf <<EOF
[nginx-http-auth]
enabled = true
filter = nginx-http-auth
action = iptables[name=HTTP, port=http, protocol=tcp]
logpath = /var/log/nginx/error.log
EOF

systemctl restart fail2ban

# Configure automatic security updates
print_msg "Setting up automatic security updates..."
cat > /etc/apt/apt.conf.d/20auto-upgrades <<EOF
APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Unattended-Upgrade "1";
EOF

# Enable AppArmor
print_msg "Enabling AppArmor..."
systemctl enable apparmor
systemctl start apparmor

# Log monitoring with logwatch
print_msg "Configuring logwatch for log monitoring..."
LOGWATCH_CRON="/etc/cron.daily/00logwatch"
if [ ! -f "$LOGWATCH_CRON" ]; then
    cat > "$LOGWATCH_CRON" <<EOF
#!/bin/bash
/usr/sbin/logwatch --output mail --mailto root --detail high
EOF
    chmod +x "$LOGWATCH_CRON"
else
    print_msg "Logwatch cron job already exists. Skipping."
fi

# Set up backup and recovery plan with rsync
print_msg "Setting up backup directory..."
if [ ! -d "$BACKUP_DIR" ]; then
    mkdir -p "$BACKUP_DIR"
    chown "$ORIGINAL_USER":"$ORIGINAL_USER" "$BACKUP_DIR"
fi

print_msg "Configuring daily backups..."
BACKUP_SCRIPT="/usr/local/bin/backup_webserver.sh"
if [ ! -f "$BACKUP_SCRIPT" ]; then
    cat > "$BACKUP_SCRIPT" <<EOF
#!/bin/bash
rsync -a --exclude='$WEB_SERVER_DIR/venv' $WEB_SERVER_DIR $BACKUP_DIR
EOF
    chmod +x "$BACKUP_SCRIPT"
    (crontab -l 2>/dev/null; echo "0 2 * * * $ORIGINAL_USER $BACKUP_SCRIPT") | crontab -
else
    print_msg "Backup script already exists. Skipping."
fi

print_msg "Setup complete. Please reboot the system to apply all changes."
