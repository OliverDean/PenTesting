#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <sys/ptrace.h>

#define KEY_A 0x12
#define KEY_B 0x9A
#define KEY_C 0x5D
#define SECRET_D 0x41

// Function Prototypes
int is_debugger_active();
char* perform_decryption(char *encrypted_pass);
char* apply_xor_key_a(char *encrypted_pass);
char* apply_xor_key_b(char *encrypted_pass);
char* apply_xor_key_c(char *encrypted_pass);
char* retrieve_password(char *encrypted_pass);
void execute_operations();
void print_admin_hint();

// Correct encrypted version of "p0lit3lyj377y" XORed with SECRET_D
const char *placeholder = "\x31\x71\x2D\x28\x35\x72\x2D\x38\x2B\x72\x76\x76\x38";

// Anti-debugging mechanism: Ptrace check
int is_debugger_active() {
    if (ptrace(PTRACE_TRACEME, 0, 1, 0) == -1) {
        printf("Debugger detected!\n");
        return 1; // Exit if debugger detected
    }
    return 0;
}

// Main decryption function (final correct step)
char* perform_decryption(char *encrypted_pass) {
    static char decrypted[20];
    for (int i = 0; i < strlen(encrypted_pass); i++) {
        decrypted[i] = encrypted_pass[i] ^ SECRET_D;
    }
    decrypted[strlen(encrypted_pass)] = '\0';  // Add null termination
    return decrypted;
}

// XOR processing with key A
char* apply_xor_key_a(char *encrypted_pass) {
    static char output[20];
    for (int i = 0; i < strlen(encrypted_pass); i++) {
        output[i] = encrypted_pass[i] ^ KEY_A;
    }
    output[strlen(encrypted_pass)] = '\0';
    return output;
}

// XOR processing with key B
char* apply_xor_key_b(char *encrypted_pass) {
    static char output[20];
    for (int i = 0; i < strlen(encrypted_pass); i++) {
        output[i] = encrypted_pass[i] ^ KEY_B;
    }
    output[strlen(encrypted_pass)] = '\0';
    return output;
}

// XOR processing with key C
char* apply_xor_key_c(char *encrypted_pass) {
    static char output[20];
    for (int i = 0; i < strlen(encrypted_pass); i++) {
        output[i] = encrypted_pass[i] ^ KEY_C;
    }
    output[strlen(encrypted_pass)] = '\0';
    return output;
}

// Control flow obfuscation: Dynamic selection and time-wasting operations
char* retrieve_password(char *encrypted_pass) {
    // Perform time-wasting operations to mislead reverse engineers
    execute_operations();
    
    // Randomize decision tree to mislead reverse engineers
    int random_choice = rand() % 3;

    char *decryption_result;
    switch (random_choice) {
        case 0:
            decryption_result = apply_xor_key_a(encrypted_pass);
            break;
        case 1:
            decryption_result = apply_xor_key_b(encrypted_pass);
            break;
        case 2:
            decryption_result = apply_xor_key_c(encrypted_pass);
            break;
        default:
            decryption_result = perform_decryption(encrypted_pass);  // Should never reach here
            break;
    }

    // Final decryption using the correct key and data
    return perform_decryption((char *)placeholder);  // Decrypt the placeholder password
}

// Time-wasting operation function to add meaningless operations
void execute_operations() {
    for (int i = 0; i < 1000; i++) {
        int x = i * 2 + i - (i % 3);
        int y = x / 4 + i * 3;
        x = y % 5;  // Completely irrelevant
    }
}

// Function to print the hint after reverse engineering the password
void print_admin_hint() {
    printf("Hmm Admin's password on the web is over 20 characters.\n");
    printf("If only the hackers were clever enough. Good Job Team!\n");
}

int main() {
    // Initialize randomness for control flow obfuscation
    srand(time(NULL));

    // Anti-debugging checks
    if (is_debugger_active()) {
        exit(1); // Exit if debugging detected
    }

    // Input and comparison
    char input[30];  
    printf("Enter password: ");
    scanf("%29s", input); // Accept user input
    
    // Decrypt the stored encrypted password (correct step)
    char *decrypted_password = retrieve_password((char *)placeholder);

    // Real password comparison
    if (strcmp(input, decrypted_password) == 0) {
        printf("Access granted.\n");
        print_admin_hint();  // Print the admin password hint after successful reverse engineering
    } else {
        printf("Access denied.\n");
    }

    return 0;
}

